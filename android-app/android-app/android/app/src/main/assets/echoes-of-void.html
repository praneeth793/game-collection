<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echoes of Void</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
        }

        #gameCanvas {
            display: block;
            cursor: none;
        }

        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
            transition: opacity 2s ease;
        }

        #startScreen h1 {
            color: #e0e0e0;
            font-size: 3rem;
            font-weight: 100;
            letter-spacing: 2rem;
            margin-bottom: 2rem;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeIn 3s ease forwards;
        }

        #startScreen p {
            color: #666;
            font-size: 0.9rem;
            letter-spacing: 0.5rem;
            opacity: 0;
            animation: fadeIn 3s ease 1s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        #fadeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
            transition: opacity 3s ease;
        }

        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 10;
        }

        #grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml,<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23noise)" opacity="0.03"/></svg>');
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>Echoes of Void</h1>
        <p>[ click to enter ]</p>
    </div>
    <div id="fadeOverlay"></div>
    <div id="vignette"></div>
    <div id="grain"></div>
    <canvas id="gameCanvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Game state
        let gameStarted = false;
        let gameEnded = false;
        let startTime = 0;
        let playerPosition = new THREE.Vector3(0, 2, 10);
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();

        // Audio context
        let audioCtx;
        let ambientOscillators = [];
        let masterGain;

        // Three.js setup
        const canvas = document.getElementById('gameCanvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.FogExp2(0x0a0a0a, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(playerPosition);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Pointer lock
        let isLocked = false;
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;

        // Movement
        const moveState = { forward: false, backward: false, left: false, right: false };
        const moveSpeed = 0.08;
        const friction = 0.92;

        // Game objects
        const floatingShapes = [];
        const pillars = [];
        const particles = [];
        const mirrorSpheres = [];

        // Initialize audio
        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);

            // Create ambient drones
            const frequencies = [55, 82.5, 110, 165];
            frequencies.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                gain.gain.value = 0.1 + (i * 0.05);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start();
                ambientOscillators.push({ osc, gain, baseFreq: freq });
            });
        }

        function playDrone(note, duration = 2) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = note;
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playStep() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(80 + Math.random() * 40, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);
        }

        function playHover() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            const freq = 200 + Math.random() * 400;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(freq * 2, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.35);
        }

        // Create abstract environment
        function createEnvironment() {
            // Floor
            const floorGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.9,
                metalness: 0.1,
                wireframe: false
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid pattern on floor
            const gridHelper = new THREE.GridHelper(200, 100, 0x222222, 0x151515);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Floating geometric shapes
            const geometries = [
                new THREE.IcosahedronGeometry(1, 0),
                new THREE.OctahedronGeometry(0.8, 0),
                new THREE.TetrahedronGeometry(0.9, 0),
                new THREE.DodecahedronGeometry(0.7, 0)
            ];

            const materials = [
                new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3, metalness: 0.8 }),
                new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.4, metalness: 0.7 }),
                new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.2, metalness: 0.9 }),
                new THREE.MeshStandardMaterial({ color: 0x383838, roughness: 0.5, metalness: 0.6 })
            ];

            for (let i = 0; i < 80; i++) {
                const geo = geometries[Math.floor(Math.random() * geometries.length)];
                const mat = materials[Math.floor(Math.random() * materials.length)];
                const mesh = new THREE.Mesh(geo, mat);
                
                const angle = (i / 80) * Math.PI * 8 + Math.random() * 2;
                const radius = 10 + Math.random() * 60;
                const height = 3 + Math.random() * 15;
                
                mesh.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                mesh.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                mesh.userData = {
                    baseY: height,
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.01,
                        y: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.01
                    },
                    floatOffset: Math.random() * Math.PI * 2,
                    floatSpeed: 0.5 + Math.random() * 0.5,
                    originalScale: 0.5 + Math.random() * 1.5,
                    radius: radius,
                    angle: angle
                };
                
                mesh.scale.setScalar(mesh.userData.originalScale * 0.5);
                mesh.castShadow = true;
                floatingShapes.push(mesh);
                scene.add(mesh);
            }

            // Tall abstract pillars
            const pillarGeo = new THREE.CylinderGeometry(0.3, 0.5, 20, 8);
            const pillarMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                roughness: 0.7,
                metalness: 0.3
            });

            for (let i = 0; i < 30; i++) {
                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 50;
                pillar.position.set(
                    Math.cos(angle) * radius,
                    10,
                    Math.sin(angle) * radius
                );
                pillar.rotation.z = (Math.random() - 0.5) * 0.3;
                pillar.rotation.x = (Math.random() - 0.5) * 0.3;
                pillar.castShadow = true;
                pillar.receiveShadow = true;
                pillars.push(pillar);
                scene.add(pillar);
            }

            // Mirror spheres
            const sphereGeo = new THREE.SphereGeometry(2, 32, 32);
            const mirrorMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0,
                metalness: 1,
                envMapIntensity: 1
            });

            for (let i = 0; i < 5; i++) {
                const sphere = new THREE.Mesh(sphereGeo, mirrorMat);
                sphere.position.set(
                    (Math.random() - 0.5) * 100,
                    5 + Math.random() * 10,
                    (Math.random() - 0.5) * 100
                );
                sphere.userData = {
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 0.5
                };
                mirrorSpheres.push(sphere);
                scene.add(sphere);
            }

            // Ambient particles
            const particleGeo = new THREE.BufferGeometry();
            const particleCount = 500;
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 150;
                positions[i * 3 + 1] = Math.random() * 30;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 150;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMat = new THREE.PointsMaterial({
                color: 0x555555,
                size: 0.1,
                transparent: true,
                opacity: 0.6
            });

            const particleSystem = new THREE.Points(particleGeo, particleMat);
            scene.add(particleSystem);
        }

        // Lighting
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x222222, 0.5);
            scene.add(ambientLight);

            // Main directional light
            const dirLight = new THREE.DirectionalLight(0x666666, 0.5);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            scene.add(dirLight);

            // Subtle colored point lights
            const colors = [0x444455, 0x554444, 0x444455];
            colors.forEach((color, i) => {
                const light = new THREE.PointLight(color, 0.5, 30);
                light.position.set(
                    (Math.random() - 0.5) * 60,
                    5 + Math.random() * 10,
                    (Math.random() - 0.5) * 60
                );
                scene.add(light);
            });
        }

        // Input handling
        function setupControls() {
            document.addEventListener('click', () => {
                if (gameStarted && !isLocked) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === canvas;
            });

            document.addEventListener('mousemove', (event) => {
                if (!isLocked || !gameStarted) return;

                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                euler.setFromQuaternion(camera.quaternion);
                euler.y -= movementX * 0.002;
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                camera.quaternion.setFromEuler(euler);
            });

            document.addEventListener('keydown', (event) => {
                if (!gameStarted) return;
                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': moveState.forward = true; break;
                    case 'KeyS': case 'ArrowDown': moveState.backward = true; break;
                    case 'KeyA': case 'ArrowLeft': moveState.left = true; break;
                    case 'KeyD': case 'ArrowRight': moveState.right = true; break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': moveState.forward = false; break;
                    case 'KeyS': case 'ArrowDown': moveState.backward = false; break;
                    case 'KeyA': case 'ArrowLeft': moveState.left = false; break;
                    case 'KeyD': case 'ArrowRight': moveState.right = false; break;
                }
            });
        }

        // Game update
        let lastStepTime = 0;
        const clock = new THREE.Clock();

        function update(time) {
            if (!gameStarted || gameEnded) return;

            const delta = clock.getDelta();
            const elapsed = time - startTime;

            // Movement
            direction.set(0, 0, 0);
            if (moveState.forward) direction.z -= 1;
            if (moveState.backward) direction.z += 1;
            if (moveState.left) direction.x -= 1;
            if (moveState.right) direction.x += 1;
            direction.normalize();

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            velocity.add(forward.multiplyScalar(direction.z * moveSpeed));
            velocity.add(right.multiplyScalar(direction.x * moveSpeed));
            velocity.multiplyScalar(friction);

            playerPosition.add(velocity);

            // Footstep sounds
            if (velocity.length() > 0.01 && time - lastStepTime > 0.4) {
                playStep();
                lastStepTime = time;
            }

            // Update camera
            camera.position.copy(playerPosition);
            camera.position.y = 2;

            // Animate floating shapes
            floatingShapes.forEach((shape, i) => {
                // Rotation
                shape.rotation.x += shape.userData.rotationSpeed.x;
                shape.rotation.y += shape.userData.rotationSpeed.y;
                shape.rotation.z += shape.userData.rotationSpeed.z;

                // Float
                const floatY = shape.userData.baseY + Math.sin(time * shape.userData.floatSpeed + shape.userData.floatOffset) * 2;
                shape.position.y = floatY;

                // React to player proximity
                const dist = shape.position.distanceTo(playerPosition);
                if (dist < 8) {
                    const scale = shape.userData.originalScale * (1 + (8 - dist) * 0.2);
                    shape.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.1);
                    
                    // Play sound occasionally when close
                    if (Math.random() < 0.01) {
                        playHover();
                    }
                } else {
                    shape.scale.lerp(new THREE.Vector3(
                        shape.userData.originalScale * 0.5,
                        shape.userData.originalScale * 0.5,
                        shape.userData.originalScale * 0.5
                    ), 0.05);
                }
            });

            // Animate mirror spheres
            mirrorSpheres.forEach((sphere, i) => {
                sphere.position.y += Math.sin(time * sphere.userData.pulseSpeed + sphere.userData.pulsePhase) * 0.01;
                sphere.rotation.y += 0.005;
                sphere.rotation.x += 0.003;
            });

            // Dynamic audio based on position
            ambientOscillators.forEach((obj, i) => {
                const modFreq = obj.baseFreq + Math.sin(time * 0.5 + i) * 5;
                obj.osc.frequency.setTargetAtTime(modFreq, audioCtx.currentTime, 0.1);
            });

            // End game after 8 minutes
            if (elapsed > 480000 && !gameEnded) {
                endGame();
            }
        }

        function endGame() {
            gameEnded = true;
            document.exitPointerLock();
            
            // Fade to white
            const fadeOverlay = document.getElementById('fadeOverlay');
            fadeOverlay.style.background = '#ffffff';
            fadeOverlay.style.opacity = '1';
            
            setTimeout(() => {
                document.getElementById('startScreen').style.display = 'flex';
                document.getElementById('startScreen').querySelector('h1').textContent = 'The void remembers';
                document.getElementById('startScreen').querySelector('p').textContent = '[ click to restart ]';
                fadeOverlay.style.opacity = '0';
                setTimeout(() => {
                    fadeOverlay.style.background = '#000';
                }, 1000);
            }, 3000);
        }

        // Animation loop
        function animate(time) {
            requestAnimationFrame(animate);

            if (gameStarted && !gameEnded) {
                update(time);
            }

            renderer.render(scene, camera);
        }

        // Start game
        function startGame() {
            if (gameStarted) return;
            
            document.getElementById('startScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('startScreen').style.display = 'none';
            }, 2000);

            initAudio();
            createEnvironment();
            setupLighting();
            setupControls();

            gameStarted = true;
            startTime = performance.now();
            canvas.requestPointerLock();
        }

        // Event listeners
        document.getElementById('startScreen').addEventListener('click', startGame);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation loop
        animate(0);
    </script>
</body>
</html>
