<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Wanderer - A Low-Poly Horror Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Georgia', serif;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            cursor: none;
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a1a1a 0%, #000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #startScreen h1 {
            color: #8b0000;
            font-size: 3rem;
            font-weight: normal;
            letter-spacing: 0.5rem;
            text-shadow: 0 0 20px rgba(139, 0, 0, 0.5);
            margin-bottom: 1rem;
            animation: flicker 3s infinite;
        }

        #startScreen .subtitle {
            color: #555;
            font-size: 1rem;
            font-style: italic;
            margin-bottom: 3rem;
        }

        #startScreen .instructions {
            color: #444;
            font-size: 0.85rem;
            text-align: center;
            line-height: 2;
            margin-bottom: 2rem;
        }

        #startScreen .start-btn {
            padding: 15px 50px;
            font-size: 1rem;
            background: transparent;
            color: #8b0000;
            border: 1px solid #8b0000;
            border-radius: 3px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.5s ease;
        }

        #startScreen .start-btn:hover {
            background: rgba(139, 0, 0, 0.1);
            box-shadow: 0 0 30px rgba(139, 0, 0, 0.3);
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            52% { opacity: 1; }
            54% { opacity: 0.9; }
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: none;
        }

        /* Sanity Meter */
        #sanity-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #sanity-label {
            color: rgba(139, 0, 0, 0.6);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 8px;
        }

        #sanity-bar {
            width: 200px;
            height: 4px;
            background: rgba(50, 0, 0, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        #sanity-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #4a0000, #8b0000);
            transition: width 0.5s ease;
        }

        /* Torch indicator */
        #torch-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
        }

        #torch-status {
            color: rgba(255, 200, 100, 0.6);
            font-size: 14px;
            letter-spacing: 2px;
        }

        /* Vignette (dark edges) */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.8) 70%, rgba(0,0,0,1) 100%);
            animation: pulseVignette 4s ease-in-out infinite;
        }

        @keyframes pulseVignette {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        /* Sanity effects */
        #sanity-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
        }

        #sanity-effects.active {
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(20, 0, 0, 0.03) 2px,
                rgba(20, 0, 0, 0.03) 4px
            );
            animation: glitch 0.1s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            25% { transform: translate(-2px, 1px); }
            50% { transform: translate(2px, -1px); }
            75% { transform: translate(-1px, -2px); }
            100% { transform: translate(0); }
        }

        /* Messages */
        #message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(139, 0, 0, 0.8);
            font-size: 18px;
            font-style: italic;
            opacity: 0;
            transition: opacity 1s ease;
            text-align: center;
            max-width: 400px;
            line-height: 1.6;
        }

        #message.visible {
            opacity: 1;
        }

        /* Footsteps */
        #footstep-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.1);
            font-size: 12px;
            opacity: 0;
        }

        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #gameOverScreen h1 {
            color: #4a0000;
            font-size: 2.5rem;
            font-weight: normal;
            letter-spacing: 0.3rem;
            margin-bottom: 1rem;
        }

        #gameOverScreen p {
            color: #555;
            font-size: 1rem;
            margin-bottom: 2rem;
        }

        #gameOverScreen .restart-btn {
            padding: 12px 40px;
            font-size: 0.9rem;
            background: transparent;
            color: #8b0000;
            border: 1px solid #8b0000;
            border-radius: 3px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        #gameOverScreen .restart-btn:hover {
            background: rgba(139, 0, 0, 0.1);
        }

        /* Warning indicator */
        #warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(139, 0, 0, 0.9);
            font-size: 24px;
            letter-spacing: 5px;
            text-transform: uppercase;
            opacity: 0;
            pointer-events: none;
            z-index: 6;
        }

        #warning.visible {
            animation: warningPulse 0.5s ease-in-out infinite;
        }

        @keyframes warningPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <h1>The Wanderer</h1>
        <div class="subtitle">Not all who wander are lost...</div>
        <div class="instructions">
            <p>WASD or Arrow Keys - Move slowly</p>
            <p>Mouse - Look around</p>
            <p>Listen carefully...</p>
            <p>Find the waystones to maintain your sanity</p>
        </div>
        <button class="start-btn" id="startBtn">Enter the Dark</button>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div id="sanity-container">
            <div id="sanity-label">Sanity</div>
            <div id="sanity-bar">
                <div id="sanity-fill"></div>
            </div>
        </div>
        <div id="torch-container">
            <div id="torch-status">Torch: üî•</div>
        </div>
        <div id="message"></div>
        <div id="footstep-indicator">‚óè</div>
        <div id="warning">IT IS NEAR</div>
    </div>

    <!-- Visual Effects -->
    <div id="vignette"></div>
    <div id="sanity-effects"></div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1>Lost to the Dark</h1>
        <p>The wanderer never returned...</p>
        <button class="restart-btn" id="restartBtn">Try Again</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Create ambient particles
        for (let i = 0; i < 50; i++) {
            const particle = document.createElement('div');
            particle.style.cssText = `
                position: fixed;
                width: 2px;
                height: 2px;
                background: rgba(100, 100, 100, 0.3);
                border-radius: 50%;
                pointer-events: none;
                left: ${Math.random() * 100}%;
                top: ${Math.random() * 100}%;
                animation: float ${3 + Math.random() * 4}s ease-in-out infinite;
                animation-delay: ${Math.random() * 3}s;
            `;
            document.body.appendChild(particle);
        }

        // Add floating animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes float {
                0%, 100% { transform: translateY(0); opacity: 0; }
                10% { opacity: 0.5; }
                90% { opacity: 0.5; }
                100% { transform: translateY(-100vh); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Game State
        let gameStarted = false;
        let gameOver = false;
        let sanity = 100;
        const maxSanity = 100;
        let entityDistance = 50;
        const entityDetectRange = 15;
        const playerSpeed = 3;
        let torchIntensity = 0.8;
        let nearbyWaystone = null;
        let nearbyShrine = null;
        let footstepsTime = 0;

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x000000, 0.08);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 1.7, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        const canvas = renderer.domElement;

        // Audio
        let audioCtx;
        let masterGain;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.5;
            masterGain.connect(audioCtx.destination);
        }

        function playSound(type) {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            switch(type) {
                case 'footstep':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    filter.type = 'lowpass';
                    filter.frequency.value = 200;
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'whisper':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400 + Math.random() * 200, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 2);
                    filter.type = 'bandpass';
                    filter.frequency.value = 500;
                    filter.Q.value = 10;
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 2);
                    break;
                case 'breath':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.5);
                    gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                    osc.connect(gain);
                    gain.connect(masterGain);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.6);
                    break;
                case 'heartbeat':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    filter.type = 'lowpass';
                    filter.frequency.value = 100;
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'waystone':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(220, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 1);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.5);
                    filter.type = 'lowpass';
                    filter.frequency.value = 1000;
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 1.5);
                    break;
                case 'ambient':
                    // Wind-like ambient
                    const noise = audioCtx.createBufferSource();
                    const bufferSize = audioCtx.sampleRate * 2;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * 0.02;
                    }
                    noise.buffer = buffer;
                    noise.loop = true;
                    const windGain = audioCtx.createGain();
                    windGain.gain.value = 0.3;
                    const windFilter = audioCtx.createBiquadFilter();
                    windFilter.type = 'lowpass';
                    windFilter.frequency.value = 200;
                    noise.connect(windFilter);
                    windFilter.connect(windGain);
                    windGain.connect(masterGain);
                    noise.start();
                    break;
                case 'scream':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 2);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 2);
                    filter.type = 'bandpass';
                    filter.frequency.value = 300;
                    filter.Q.value = 5;
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(masterGain);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 2);
                    break;
                case 'wind':
                    const windOsc = audioCtx.createOscillator();
                    const windGain2 = audioCtx.createGain();
                    const windFilter2 = audioCtx.createBiquadFilter();
                    windOsc.type = 'triangle';
                    windOsc.frequency.value = 50 + Math.random() * 30;
                    windGain2.gain.value = 0.02;
                    windFilter2.type = 'lowpass';
                    windFilter2.frequency.value = 150;
                    windOsc.connect(windFilter2);
                    windFilter2.connect(windGain2);
                    windGain2.connect(masterGain);
                    windOsc.start();
                    windOsc.stop(audioCtx.currentTime + 0.1);
                    break;
            }
        }

        // Player
        const player = {
            position: new THREE.Vector3(0, 1.7, 0),
            velocity: new THREE.Vector3(),
            radius: 0.3
        };

        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;

        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // World objects
        const trees = [];
        const rocks = [];
        const waystones = [];
        const shrines = [];
        const fogParticles = [];

        // Materials
        const materials = {
            ground: new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 }),
            trunk: new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.8 }),
            leaves: new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.9 }),
            rock: new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.7 }),
            waystone: new THREE.MeshStandardMaterial({ 
                color: 0x3a2a1a, 
                emissive: 0x4a3a2a,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.9
            }),
            shrine: new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a,
                emissive: 0x6a4a3a,
                emissiveIntensity: 0.1
            }),
            rune: new THREE.MeshBasicMaterial({ color: 0x8a6a5a })
        };

        function createWorld() {
            // Ground
            const groundGeo = new THREE.PlaneGeometry(500, 500, 100, 100);
            
            // Add some terrain variation
            const vertices = groundGeo.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] += Math.random() * 0.5;
            }
            groundGeo.computeVertexNormals();

            const ground = new THREE.Mesh(groundGeo, materials.ground);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create dark forest
            createForest();

            // Create waystones
            createWaystones();

            // Create shrines
            createShrines();

            // Create fog particles
            createFogParticles();

            // Start ambient sounds
            playSound('ambient');
        }

        function createForest() {
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 4, 6);
            const leavesGeo = new THREE.ConeGeometry(2, 4, 4);

            for (let i = 0; i < 300; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 150;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;

                // Skip center area
                if (distance < 8) continue;

                // Create tree
                const trunk = new THREE.Mesh(trunkGeo, materials.trunk);
                trunk.position.set(x, 2, z);
                trunk.rotation.y = Math.random() * Math.PI;
                trunk.castShadow = true;
                scene.add(trunk);
                trees.push({ mesh: trunk, x, z });

                // Leaves (low-poly)
                const leaves = new THREE.Mesh(leavesGeo, materials.leaves);
                leaves.position.set(x, 5, z);
                leaves.rotation.y = Math.random() * Math.PI;
                leaves.rotation.x = (Math.random() - 0.5) * 0.5;
                leaves.castShadow = true;
                scene.add(leaves);

                // Random rocks
                if (Math.random() < 0.1) {
                    const rockGeo = new THREE.DodecahedronGeometry(0.5 + Math.random() * 1, 0);
                    const rock = new THREE.Mesh(rockGeo, materials.rock);
                    rock.position.set(x + (Math.random() - 0.5) * 3, 0.3, z + (Math.random() - 0.5) * 3);
                    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                    rock.castShadow = true;
                    scene.add(rock);
                    rocks.push({ mesh: rock });
                }
            }
        }

        function createWaystones() {
            const waystoneGeo = new THREE.TorusGeometry(0.5, 0.1, 6, 12);

            // Create 8 waystones in a pattern
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const distance = 30 + Math.random() * 20;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;

                const waystone = new THREE.Mesh(waystoneGeo, materials.waystone.clone());
                waystone.position.set(x, 1.5, z);
                waystone.rotation.x = Math.PI / 2;
                waystone.rotation.z = Math.random() * Math.PI;
                scene.add(waystone);

                // Add glow light
                const light = new THREE.PointLight(0x8a6a5a, 0.5, 8);
                light.position.set(x, 1.5, z);
                scene.add(light);

                // Vertical pillar
                const pillarGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.5, 6);
                const pillar = new THREE.Mesh(pillarGeo, materials.rock);
                pillar.position.set(x, 0.75, z);
                scene.add(pillar);

                waystones.push({
                    mesh: waystone,
                    light,
                    position: new THREE.Vector3(x, 1.5, z),
                    active: false,
                    id: i
                });
            }
        }

        function createShrines() {
            // Create central shrine
            const shrineGeo = new THREE.CylinderGeometry(1, 1.2, 2, 6);
            const shrine = new THREE.Mesh(shrineGeo, materials.shrine.clone());
            shrine.position.set(0, 1, 0);
            shrine.castShadow = true;
            scene.add(shrine);

            // Runes on shrine
            const runeGeo = new THREE.TorusGeometry(0.3, 0.05, 6, 8);
            for (let i = 0; i < 3; i++) {
                const rune = new THREE.Mesh(runeGeo, materials.rune);
                rune.position.set(0, 1 + i * 0.5, 1);
                rune.rotation.x = Math.PI / 4;
                scene.add(rune);
            }

            shrines.push({
                mesh: shrine,
                position: new THREE.Vector3(0, 1, 0)
            });

            // Central light
            const centerLight = new THREE.PointLight(0x6a4a3a, 1, 15);
            centerLight.position.set(0, 3, 0);
            scene.add(centerLight);
        }

        function createFogParticles() {
            const particleGeo = new THREE.BufferGeometry();
            const count = 100;
            const positions = new Float32Array(count * 3);

            for (let i = 0; i < count * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 200;
                positions[i + 1] = Math.random() * 10;
                positions[i + 2] = (Math.random() - 0.5) * 200;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMat = new THREE.PointsMaterial({
                color: 0x333333,
                size: 0.5,
                transparent: true,
                opacity: 0.3
            });

            const particles = new THREE.Points(particleGeo, particleMat);
            scene.add(particles);
        }

        // Lighting
        function setupLighting() {
            // Very dim ambient light
            const ambientLight = new THREE.AmbientLight(0x111111, 0.3);
            scene.add(ambientLight);

            // Player's torch (attached to camera)
            const torchLight = new THREE.SpotLight(0xffaa55, torchIntensity, 20, Math.PI / 4, 0.5, 1);
            torchLight.position.set(0, 0, 0);
            torchLight.target.position.set(0, 0, -1);
            camera.add(torchLight);
            camera.add(torchLight.target);
            scene.add(camera);

            // Moon (distant light)
            const moonLight = new THREE.DirectionalLight(0x222244, 0.1);
            moonLight.position.set(50, 100, 50);
            scene.add(moonLight);
        }

        // Controls
        function setupControls() {
            canvas.addEventListener('click', () => {
                if (gameStarted && !gameOver) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('mousemove', (event) => {
                if (!gameStarted || gameOver || document.pointerLockElement !== canvas) return;

                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                euler.setFromQuaternion(camera.quaternion);
                euler.y -= movementX * 0.0015;
                euler.x -= movementY * 0.0015;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                camera.quaternion.setFromEuler(euler);
            });

            document.addEventListener('keydown', (event) => {
                if (!gameStarted || gameOver) return;

                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': moveState.forward = true; break;
                    case 'KeyS': case 'ArrowDown': moveState.backward = true; break;
                    case 'KeyA': case 'ArrowLeft': moveState.left = true; break;
                    case 'KeyD': case 'ArrowRight': moveState.right = true; break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': moveState.forward = false; break;
                    case 'KeyS': case 'ArrowDown': moveState.backward = false; break;
                    case 'KeyA': case 'ArrowLeft': moveState.left = false; break;
                    case 'KeyD': case 'ArrowRight': moveState.right = false; break;
                }
            });
        }

        function updatePlayer(delta) {
            // Slow movement
            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            if (moveState.forward) direction.add(forward);
            if (moveState.backward) direction.sub(forward);
            if (moveState.left) direction.sub(right);
            if (moveState.right) direction.add(right);

            if (direction.length() > 0) {
                direction.normalize();
                
                const newPos = player.position.clone();
                newPos.x += direction.x * playerSpeed * delta;
                newPos.z += direction.z * playerSpeed * delta;

                // Keep within bounds
                newPos.x = Math.max(-200, Math.min(200, newPos.x));
                newPos.z = Math.max(-200, Math.min(200, newPos.z));

                player.position.copy(newPos);

                // Footstep sounds
                footstepsTime += delta;
                if (footstepsTime > 0.5) {
                    footstepsTime = 0;
                    playSound('footstep');
                }
            }

            // Check nearby waystones
            nearbyWaystone = null;
            let minDist = 5;
            for (const waystone of waystones) {
                const dist = player.position.distanceTo(waystone.position);
                if (dist < minDist && !waystone.active) {
                    nearbyWaystone = waystone;
                    minDist = dist;
                }
            }

            // Update camera
            camera.position.copy(player.position);
        }

        function updateEntity(delta, time) {
            // Entity slowly approaches player
            const approachRate = 0.3 + (1 - sanity / maxSanity) * 0.5;
            entityDistance -= approachRate * delta;

            // Random whisper sounds
            if (Math.random() < 0.01) {
                playSound('whisper');
            }

            // Heavy breathing when entity is close
            if (entityDistance < 30) {
                if (Math.random() < 0.02) {
                    playSound('breath');
                }
            }

            // Warning when entity is very close
            const warningEl = document.getElementById('warning');
            if (entityDistance < entityDetectRange) {
                warningEl.classList.add('visible');
                playSound('heartbeat');

                // Sanity drains faster
                sanity -= delta * 10;

                // Random glitch effect
                if (Math.random() < 0.02) {
                    document.body.style.filter = 'invert(0.1)';
                    setTimeout(() => document.body.style.filter = '', 100);
                }
            } else {
                warningEl.classList.remove('visible');
            }

            // Check if entity caught player
            if (entityDistance <= 0) {
                endGame();
            }
        }

        function updateWaystones(time) {
            for (const waystone of waystones) {
                // Rotate waystone
                waystone.mesh.rotation.z += 0.005;

                // Pulse light
                waystone.light.intensity = 0.3 + Math.sin(time * 2) * 0.2;

                // Check if player is nearby
                const dist = player.position.distanceTo(waystone.position);
                if (dist < 3 && !waystone.active) {
                    // Activate waystone
                    waystone.active = true;
                    waystone.mesh.material.emissiveIntensity = 0.8;
                    waystone.light.intensity = 1;
                    sanity = Math.min(maxSanity, sanity + 30);
                    entityDistance = Math.min(entityDistance + 20, 50);
                    playSound('waystone');
                    showMessage("The ancient stone glows... your mind clears.");

                    // Visual effect
                    waystone.mesh.scale.setScalar(1.5);
                }
            }
        }

        function updateEnvironment(time) {
            // Flicker torch
            torchIntensity = 0.7 + Math.sin(time * 10) * 0.1 + Math.random() * 0.1;
            
            // Update sanity bar
            const sanityFill = document.getElementById('sanity-fill');
            sanityFill.style.width = `${(sanity / maxSanity) * 100}%`;
            
            // Change color based on sanity
            if (sanity < 30) {
                sanityFill.style.background = '#8b0000';
                document.getElementById('sanity-effects').classList.add('active');
            } else {
                sanityFill.style.background = 'linear-gradient(90deg, #4a0000, #8b0000)';
                document.getElementById('sanity-effects').classList.remove('active');
            }

            // Check sanity
            if (sanity <= 0) {
                endGame();
            }

            // Wind sounds
            if (Math.random() < 0.02) {
                playSound('wind');
            }
        }

        function showMessage(text) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.classList.add('visible');
            setTimeout(() => messageEl.classList.remove('visible'), 3000);
        }

        function endGame() {
            gameOver = true;
            playSound('scream');
            document.exitPointerLock();
            document.getElementById('hud').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function restartGame() {
            location.reload();
        }

        // Main update
        let time = 0;
        function update() {
            const delta = Math.min(0.05, 1/60);
            time += delta;

            updatePlayer(delta);
            updateEntity(delta, time);
            updateWaystones(time);
            updateEnvironment(time);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        // Game start
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            initAudio();
            createWorld();
            setupLighting();
            setupControls();

            gameStarted = true;
            showMessage("Find the ancient waystones... they will protect you.");
            canvas.requestPointerLock();
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', restartGame);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
