<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Cloud Hop - Mobile 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F6FF 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
        }

        #startScreen h1 {
            color: #fff;
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            margin-bottom: 1rem;
        }

        #startScreen .subtitle {
            color: rgba(255,255,255,0.9);
            font-size: clamp(1rem, 4vw, 1.5rem);
            margin-bottom: 2rem;
        }

        #startScreen .tap-hint {
            color: rgba(255,255,255,0.8);
            font-size: clamp(0.8rem, 3vw, 1rem);
            padding: 1rem 2rem;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 2rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: clamp(10px, 3vw, 20px);
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .hud-item {
            background: rgba(255,255,255,0.9);
            padding: clamp(8px, 2vw, 12px) clamp(15px, 4vw, 20px);
            border-radius: 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .hud-label {
            font-size: clamp(0.6rem, 2vw, 0.8rem);
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .hud-value {
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: bold;
            color: #333;
        }

        /* Touch Controls */
        #controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            display: none;
            z-index: 10;
        }

        .control-zone {
            position: absolute;
            bottom: 0;
            width: 50%;
            height: 100%;
            touch-action: none;
        }

        #leftZone {
            left: 0;
        }

        #rightZone {
            right: 0;
        }

        .control-hint {
            position: absolute;
            bottom: clamp(20px, 5vh, 40px);
            font-size: clamp(0.7rem, 2.5vw, 1rem);
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        #leftHint {
            left: 25%;
            transform: translateX(-50%);
        }

        #rightHint {
            right: 25%;
            transform: translateX(50%);
        }

        /* End Screen */
        #endScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #FFE4B5 0%, #FFB347 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #endScreen h1 {
            color: #fff;
            font-size: clamp(2rem, 8vw, 3.5rem);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            margin-bottom: 1rem;
        }

        #endScreen .score-display {
            background: rgba(255,255,255,0.9);
            padding: clamp(15px, 4vw, 25px) clamp(30px, 8vw, 50px);
            border-radius: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        #endScreen .final-score {
            font-size: clamp(2.5rem, 10vw, 4rem);
            font-weight: bold;
            color: #333;
        }

        #endScreen .score-label {
            font-size: clamp(0.8rem, 3vw, 1rem);
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        #endScreen .restart-hint {
            color: rgba(255,255,255,0.9);
            font-size: clamp(0.9rem, 3.5vw, 1.2rem);
            padding: 1rem 2rem;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 2rem;
        }

        /* Progress indicator */
        #progressBar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            z-index: 15;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <h1>Cloud Hop</h1>
        <div class="subtitle">Jump through the clouds!</div>
        <div class="tap-hint">Tap to Play</div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-item">
            <div class="hud-label">Score</div>
            <div class="hud-value" id="scoreDisplay">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Height</div>
            <div class="hud-value" id="heightDisplay">0m</div>
        </div>
    </div>

    <!-- Progress Bar -->
    <div id="progressBar" style="width: 0%"></div>

    <!-- Touch Controls -->
    <div id="controls">
        <div class="control-zone" id="leftZone"></div>
        <div class="control-hint" id="leftHint">← Move</div>
        <div class="control-zone" id="rightZone"></div>
        <div class="control-hint" id="rightHint">Jump →</div>
    </div>

    <!-- End Screen -->
    <div id="endScreen">
        <h1>Game Over</h1>
        <div class="score-display">
            <div class="final-score" id="finalScore">0</div>
            <div class="score-label">Points</div>
        </div>
        <div class="restart-hint">Tap to Try Again</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        console.log('Cloud Hop: Module loaded successfully');
        console.log('Three.js version:', THREE.REVISION);

        // Game State
        let gameStarted = false;
        let gameEnded = false;
        let score = 0;
        let maxHeight = 0;

        // Expose game state to window for testing
        window.gameState = {
            getGameStarted: () => gameStarted,
            getGameEnded: () => gameEnded,
            getScore: () => score,
            getMaxHeight: () => maxHeight
        };

        // Expose startGame for testing
        window.startGameViaEval = function() {
            console.log('startGameViaEval called');
            startGame();
        };

        // Responsive canvas sizing
        const isMobile = window.innerWidth < 768 || window.innerHeight < 500;

        // Three.js Setup - Optimized for mobile
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 3, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "low-power" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Player
        const player = {
            mesh: null,
            velocity: new THREE.Vector3(0, 0, 0),
            isJumping: false,
            onPlatform: null
        };

        // Materials - Simple and lightweight
        const materials = {
            player: new THREE.MeshLambertMaterial({ color: 0xFF6B6B }),
            cloud: new THREE.MeshLambertMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.9 }),
            platform: new THREE.MeshLambertMaterial({ color: 0x98D8C7 }),
            sky: new THREE.MeshBasicMaterial({ color: 0x87CEEB }),
            ground: new THREE.MeshLambertMaterial({ color: 0x90EE90 })
        };

        // Game Objects
        const platforms = [];
        const clouds = [];
        const decorations = [];

        // Control State
        const controls = {
            left: false,
            right: false,
            jump: false
        };

        function createPlayer() {
            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            player.mesh = new THREE.Mesh(geometry, materials.player);
            player.mesh.position.set(0, 1, 0);
            scene.add(player.mesh);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.15, 0.15, 0.35);
            player.mesh.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.15, 0.15, 0.35);
            player.mesh.add(rightEye);
        }

        function createPlatform(x, y, z, width, depth) {
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, materials.platform);
            platform.position.set(x, y, z);
            scene.add(platform);

            platforms.push({
                mesh: platform,
                width: width,
                depth: depth,
                collected: false
            });

            return platform;
        }

        function createCloud(x, y, z) {
            const group = new THREE.Group();

            // Main cloud body - simple spheres
            const sphereGeo = new THREE.SphereGeometry(1, 8, 8);
            const positions = [
                { x: 0, y: 0, z: 0, s: 1.5 },
                { x: 1.2, y: -0.3, z: 0, s: 1.2 },
                { x: -1.2, y: -0.2, z: 0, s: 1.3 },
                { x: 0.6, y: 0.4, z: 0, s: 1 },
                { x: -0.5, y: 0.3, z: 0.5, s: 1.1 },
                { x: 0.3, y: -0.1, z: -0.5, s: 1 }
            ];

            positions.forEach(pos => {
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(pos.s, 6, 6),
                    materials.cloud
                );
                sphere.position.set(pos.x, pos.y, pos.z);
                group.add(sphere);
            });

            group.position.set(x, y, z);
            scene.add(group);

            clouds.push({
                group: group,
                baseY: y,
                phase: Math.random() * Math.PI * 2
            });

            return group;
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(100, 100);
            const ground = new THREE.Mesh(geometry, materials.ground);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -5;
            scene.add(ground);
        }

        function generateWorld() {
            // Starting platform
            createPlatform(0, 0, 0, 4, 4);

            // Generate platforms going up
            let lastX = 0;
            let lastY = 0;
            let lastZ = 0;

            for (let i = 0; i < 50; i++) {
                const angle = (i * 0.5) + (Math.random() - 0.5) * 0.3;
                const distance = 3 + Math.random() * 2;
                const height = 1.5 + Math.random() * 1.5;
                const width = 2 + Math.random() * 2;
                const depth = 2 + Math.random() * 2;

                const x = lastX + Math.sin(angle) * distance;
                const y = lastY + height;
                const z = lastZ + Math.cos(angle) * distance;

                createPlatform(x, y, z, width, depth);

                // Add clouds around platforms
                if (Math.random() > 0.3) {
                    createCloud(
                        x + (Math.random() - 0.5) * 5,
                        y + 2 + Math.random() * 2,
                        z + (Math.random() - 0.5) * 5
                    );
                }

                lastX = x;
                lastY = y;
                lastZ = z;
            }
        }

        function setupControls() {
            // Touch controls
            const leftZone = document.getElementById('leftZone');
            const rightZone = document.getElementById('rightZone');

            // Left zone - movement
            leftZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                controls.left = true;
            });
            leftZone.addEventListener('touchend', () => {
                controls.left = false;
            });

            // Right zone - jump
            rightZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                controls.jump = true;
            });
            rightZone.addEventListener('touchend', () => {
                controls.jump = false;
            });

            // Keyboard controls for testing
            document.addEventListener('keydown', (e) => {
                if (!gameStarted || gameEnded) return;
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') controls.left = true;
                if (e.code === 'ArrowRight' || e.code === 'KeyD') controls.right = true;
                if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') controls.jump = true;
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') controls.left = false;
                if (e.code === 'ArrowRight' || e.code === 'KeyD') controls.right = false;
                if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') controls.jump = false;
            });
        }

        function updatePlayer(delta) {
            const moveSpeed = 8;
            const jumpForce = 12;
            const gravity = -30;

            // Horizontal movement
            if (controls.left) {
                player.velocity.x = -moveSpeed * delta;
            } else if (controls.right) {
                player.velocity.x = moveSpeed * delta;
            } else {
                player.velocity.x *= 0.9;
            }

            // Jumping
            if (controls.jump && player.onPlatform) {
                player.velocity.y = jumpForce;
                player.isJumping = true;
                player.onPlatform = null;
            }

            // Apply gravity
            player.velocity.y += gravity * delta;

            // Update position
            player.mesh.position.add(player.velocity.clone().multiplyScalar(delta * 60));

            // Update height
            maxHeight = Math.max(maxHeight, Math.floor(player.mesh.position.y));
            document.getElementById('heightDisplay').textContent = `${maxHeight}m`;

            // Platform collision
            if (player.velocity.y < 0) {
                for (const platform of platforms) {
                    const pPos = platform.mesh.position;
                    const halfW = platform.width / 2;
                    const halfD = platform.depth / 2;

                    if (player.mesh.position.x > pPos.x - halfW &&
                        player.mesh.position.x < pPos.x + halfW &&
                        player.mesh.position.z > pPos.z - halfD &&
                        player.mesh.position.z < pPos.z + halfD) {

                        if (player.mesh.position.y > pPos.y + 0.5 &&
                            player.mesh.position.y < pPos.y + 1.5) {
                            player.mesh.position.y = pPos.y + 0.9;
                            player.velocity.y = 0;
                            player.isJumping = false;
                            player.onPlatform = platform;

                            // Score for reaching new platforms
                            if (!platform.collected) {
                                platform.collected = true;
                                score += 10;
                                document.getElementById('scoreDisplay').textContent = score;
                            }
                            break;
                        }
                    }
                }
            }

            // Check if fallen
            if (player.mesh.position.y < -10) {
                endGame();
            }

            // Update player mesh rotation
            player.mesh.rotation.y += delta * 2;
        }

        function updateCamera() {
            // Smooth follow
            const targetPos = player.mesh.position.clone();
            targetPos.y += 2;
            targetPos.z += 8;

            camera.position.lerp(targetPos, 0.05);
            camera.lookAt(player.mesh.position);
        }

        function updateEnvironment(time) {
            // Animate clouds
            clouds.forEach((cloud, i) => {
                cloud.group.position.y = cloud.baseY + Math.sin(time + cloud.phase) * 0.3;
            });

            // Update progress bar
            const progress = Math.min(100, Math.max(0, (maxHeight / 60) * 100));
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        function startGame() {
            console.log('startGame function called');
            gameStarted = true;
            gameEnded = false;
            score = 0;
            maxHeight = 0;

            console.log('Setting display styles...');
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('endScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('scoreDisplay').textContent = '0';
            document.getElementById('heightDisplay').textContent = '0m';

            console.log('Resetting player...');
            // Reset player
            player.mesh.position.set(0, 1, 0);
            player.velocity.set(0, 0, 0);
            player.isJumping = false;
            player.onPlatform = null;

            // Reset platforms
            platforms.forEach(p => p.collected = false);

            console.log('startGame completed');
        }

        function endGame() {
            gameEnded = true;

            document.getElementById('hud').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('endScreen').style.display = 'flex';
            document.getElementById('finalScore').textContent = score;
        }

        function restartGame() {
            // Clear existing objects
            platforms.forEach(p => scene.remove(p.mesh));
            clouds.forEach(c => scene.remove(c.group));
            platforms.length = 0;
            clouds.length = 0;

            // Regenerate world
            generateWorld();

            // Start fresh
            startGame();
        }

        // Animation Loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            const delta = Math.min(0.05, (time - lastTime) / 1000);
            lastTime = time;

            if (gameStarted && !gameEnded) {
                updatePlayer(delta);
                updateCamera();
                updateEnvironment(time / 1000);
            }

            renderer.render(scene, camera);
        }

        // Initialize
        function init() {
            createGround();
            createPlayer();
            generateWorld();
            setupControls();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            // Event listeners
            document.getElementById('startScreen').addEventListener('click', startGame);
            document.getElementById('startScreen').addEventListener('touchstart', startGame);
            document.getElementById('endScreen').addEventListener('click', restartGame);
            document.getElementById('endScreen').addEventListener('touchstart', restartGame);

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate(0);
        }

        init();
    </script>
</body>
</html>
