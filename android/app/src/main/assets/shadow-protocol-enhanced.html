<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Protocol - Enhanced FPS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            cursor: none;
        }

        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Health Bar */
        #health-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 250px;
        }

        #health-label {
            color: #fff;
            font-size: 14px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #health-bar-bg {
            width: 100%;
            height: 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #444;
            border-radius: 4px;
            overflow: hidden;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.3s ease;
        }

        #health-text {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            margin-top: 5px;
            text-align: right;
        }

        /* Boss Health Bar */
        #boss-health-container {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            display: none;
        }

        #boss-health-container.visible {
            display: block;
        }

        #boss-name {
            color: #e74c3c;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-align: center;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #e74c3c;
        }

        #boss-health-bar-bg {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #e74c3c;
            border-radius: 6px;
            overflow: hidden;
        }

        #boss-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #c0392b, #e74c3c);
            transition: width 0.2s ease;
        }

        /* Weapon Display */
        #weapon-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
        }

        #weapon-name {
            color: #f39c12;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #ammo-display {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #ammo-label {
            color: #aaa;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #reload-indicator {
            color: #f39c12;
            font-size: 16px;
            margin-top: 10px;
            opacity: 0;
        }

        #reload-indicator.visible {
            opacity: 1;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            50% { opacity: 0.5; }
        }

        /* Weapon Icons */
        #weapon-icons {
            position: absolute;
            bottom: 120px;
            right: 30px;
            display: flex;
            gap: 10px;
        }

        .weapon-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #444;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            opacity: 0.5;
        }

        .weapon-slot.active {
            border-color: #f39c12;
            opacity: 1;
            box-shadow: 0 0 10px #f39c12;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair.spread::before {
            height: 15px;
        }

        #crosshair.spread::after {
            width: 15px;
        }

        /* Score */
        #score-container {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
        }

        #score {
            font-size: 32px;
            color: #fff;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #kills {
            color: #aaa;
            font-size: 14px;
        }

        /* Wave Info */
        #wave-container {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        #wave-number {
            font-size: 28px;
            color: #f39c12;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #enemies-remaining {
            color: #aaa;
            font-size: 14px;
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
        }

        #startScreen h1 {
            color: #e74c3c;
            font-size: 4rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.5rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(231, 76, 60, 0.5);
        }

        #startScreen h2 {
            color: #fff;
            font-size: 1.5rem;
            font-weight: 300;
            margin-bottom: 2rem;
            letter-spacing: 0.3rem;
        }

        #startScreen .instructions {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 2rem;
            text-align: center;
            line-height: 2;
        }

        #startScreen .start-btn {
            padding: 15px 50px;
            font-size: 1.2rem;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        #startScreen .start-btn:hover {
            background: #c0392b;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(231, 76, 60, 0.5);
        }

        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #gameOverScreen h1 {
            color: #e74c3c;
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 1rem;
        }

        #final-score {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }

        #restartBtn {
            padding: 15px 50px;
            font-size: 1.2rem;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s ease;
        }

        #restartBtn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        /* Damage overlay */
        #damageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(139, 0, 0, 0.6) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.1s;
        }

        /* Muzzle flash */
        #muzzleFlash {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 150px;
            height: 150px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(255, 200, 100, 0.9) 0%, transparent 70%);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
        }

        /* Kill feed */
        #killFeed {
            position: absolute;
            top: 80px;
            right: 20px;
            text-align: right;
        }

        .kill-message {
            color: #fff;
            font-size: 14px;
            margin-bottom: 5px;
            opacity: 1;
            transition: opacity 0.5s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        /* Pickup notification */
        #pickup-notification {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #f39c12;
            padding: 15px 30px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
        }

        #pickup-notification.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div id="crosshair"></div>
        <div id="damageOverlay"></div>
        <div id="muzzleFlash"></div>

        <div id="wave-container">
            <div id="wave-number">WAVE 1</div>
            <div id="enemies-remaining">Enemies: 0</div>
        </div>

        <div id="score-container">
            <div id="score">0</div>
            <div id="kills">0 KILLS</div>
        </div>

        <div id="health-container">
            <div id="health-label">Health</div>
            <div id="health-bar-bg">
                <div id="health-bar"></div>
            </div>
            <div id="health-text">100 / 100</div>
        </div>

        <div id="boss-health-container">
            <div id="boss-name">‚öîÔ∏è TITAN OVERLORD ‚öîÔ∏è</div>
            <div id="boss-health-bar-bg">
                <div id="boss-health-bar"></div>
            </div>
        </div>

        <div id="weapon-icons">
            <div class="weapon-slot active" id="slot-1">üî´</div>
            <div class="weapon-slot" id="slot-2">üñäÔ∏è</div>
            <div class="weapon-slot" id="slot-3">üí•</div>
            <div class="weapon-slot" id="slot-4">üéØ</div>
            <div class="weapon-slot" id="slot-5">üöÄ</div>
        </div>

        <div id="weapon-container">
            <div id="weapon-name">Pistol</div>
            <div id="ammo-display">30 / 90</div>
            <div id="ammo-label">AMMO</div>
            <div id="reload-indicator">[R] RELOADING...</div>
        </div>

        <div id="killFeed"></div>
    </div>

    <!-- Pickup Notification -->
    <div id="pickup-notification"></div>

    <!-- Start Screen -->
    <div id="startScreen">
        <h1>Shadow Protocol</h1>
        <h2>Enhanced FPS Arena</h2>
        <div class="instructions">
            <p>WASD - Move | MOUSE - Aim | CLICK - Shoot</p>
            <p>1-5 - Switch Weapon | R - Reload | SPACE - Jump</p>
            <p>Collect weapons and ammo drops!</p>
        </div>
        <button class="start-btn" id="startBtn">CLICK TO START</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1>MISSION FAILED</h1>
        <div id="final-score">Final Score: 0</div>
        <button id="restartBtn">TRY AGAIN</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Game State
        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let kills = 0;
        let wave = 1;
        let enemiesRemaining = 0;
        let health = 100;
        const maxHealth = 100;
        let isReloading = false;
        let lastShotTime = 0;
        let enemies = [];
        let ammoDrops = [];
        let weaponDrops = [];

        // Weapons System
        const weapons = {
            pistol: {
                name: 'Pistol',
                icon: 'üî´',
                damage: 34,
                fireRate: 200,
                maxAmmo: 30,
                spread: 0.01,
                auto: false,
                color: 0xffff00
            },
            rifle: {
                name: 'Assault Rifle',
                icon: 'üñäÔ∏è',
                damage: 20,
                fireRate: 100,
                maxAmmo: 40,
                spread: 0.02,
                auto: true,
                color: 0x00ff00
            },
            shotgun: {
                name: 'Shotgun',
                icon: 'üí•',
                damage: 15,
                fireRate: 600,
                maxAmmo: 8,
                spread: 0.1,
                pellets: 8,
                auto: false,
                color: 0xff6600
            },
            sniper: {
                name: 'Sniper',
                icon: 'üéØ',
                damage: 150,
                fireRate: 1000,
                maxAmmo: 5,
                spread: 0,
                auto: false,
                zoom: true,
                color: 0x00ffff
            },
            rocket: {
                name: 'Rocket Launcher',
                icon: 'üöÄ',
                damage: 200,
                fireRate: 1500,
                maxAmmo: 3,
                spread: 0,
                explosive: true,
                auto: false,
                color: 0xff00ff
            }
        };

        let currentWeapon = 'pistol';
        let ammo = { pistol: 30, rifle: 40, shotgun: 8, sniper: 5, rocket: 3 };
        let totalAmmo = { pistol: 90, rifle: 120, shotgun: 24, sniper: 15, rocket: 9 };

        // Player
        let player = {
            position: new THREE.Vector3(0, 2, 0),
            velocity: new THREE.Vector3(),
            onGround: true,
            speed: 15,
            jumpForce: 15
        };

        // Controls
        let moveState = { forward: false, backward: false, left: false, right: false, shoot: false };
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;

        // Three.js
        const canvas = document.getElementById('gameCanvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.FogExp2(0x1a1a2e, 0.025);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(player.position);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Audio
        let audioCtx;
        let masterGain;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);
        }

        function playSound(type, weapon = 'pistol') {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const weaponData = weapons[weapon];

            switch(type) {
                case 'shoot':
                    if (weapon === 'shotgun') {
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.3);
                    } else if (weapon === 'sniper') {
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.5);
                    } else if (weapon === 'rocket') {
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.5);
                    } else {
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                    }
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (weapon === 'shotgun' ? 0.3 : 0.1));
                    break;
                case 'explosion':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(50, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.5);
                    gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    break;
                case 'hit':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    break;
                case 'reload':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                    osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    break;
                case 'empty':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                    break;
                case 'pickup':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                    osc.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    break;
                case 'damage':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    break;
            }

            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        // Arena Environment
        const arenaSize = 80;
        const walls = [];

        function createArena() {
            const floorGeo = new THREE.PlaneGeometry(arenaSize, arenaSize, 20, 20);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x2c3e50,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            const gridHelper = new THREE.GridHelper(arenaSize, 40, 0x34495e, 0x2c3e50);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            const wallGeo = new THREE.BoxGeometry(arenaSize, 15, 2);
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0x34495e,
                roughness: 0.5,
                metalness: 0.3
            });

            for (let i = 0; i < 4; i++) {
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.y = 7.5;

                if (i < 2) {
                    wall.position.z = (i === 0 ? 1 : -1) * arenaSize / 2;
                } else {
                    wall.position.z = 0;
                    wall.rotation.y = Math.PI / 2;
                    wall.position.x = (i === 2 ? 1 : -1) * arenaSize / 2;
                }

                wall.castShadow = true;
                wall.receiveShadow = true;
                walls.push(wall);
                scene.add(wall);
            }

            const coverPositions = [
                { x: -20, z: -20 }, { x: 20, z: -20 },
                { x: -20, z: 20 }, { x: 20, z: 20 },
                { x: 0, z: -15 }, { x: 0, z: 15 },
                { x: -15, z: 0 }, { x: 15, z: 0 }
            ];

            coverPositions.forEach(pos => {
                const coverGeo = new THREE.BoxGeometry(8, 6, 4);
                const cover = new THREE.Mesh(coverGeo, wallMat);
                cover.position.set(pos.x, 3, pos.z);
                cover.castShadow = true;
                cover.receiveShadow = true;
                walls.push(cover);
                scene.add(cover);
            });
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(30, 50, 30);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 150;
            mainLight.shadow.camera.left = -50;
            mainLight.shadow.camera.right = 50;
            mainLight.shadow.camera.top = 50;
            mainLight.shadow.camera.bottom = -50;
            scene.add(mainLight);

            const colors = [0xe74c3c, 0x3498db, 0xf39c12];
            colors.forEach((color, i) => {
                const light = new THREE.PointLight(color, 0.5, 40);
                const angle = (i / 3) * Math.PI * 2;
                light.position.set(Math.cos(angle) * 25, 10, Math.sin(angle) * 25);
                scene.add(light);
            });
        }

        // Enemy Class
        class Enemy {
            constructor(position, isBoss = false) {
                this.isBoss = isBoss;
                this.health = isBoss ? 300 : 50 + (wave * 5);
                this.maxHealth = this.health;
                this.speed = isBoss ? 5 : 8;
                this.damage = isBoss ? 20 : 10;
                this.attackCooldown = 0;
                this.attackRate = isBoss ? 0.8 : 1;
                this.alive = true;
                this.chargeCooldown = 0;
                this.isCharging = false;

                if (isBoss) {
                    const bodyGeo = new THREE.BoxGeometry(4, 8, 4);
                    const bodyMat = new THREE.MeshStandardMaterial({
                        color: 0xc0392b,
                        roughness: 0.2,
                        metalness: 0.9,
                        emissive: 0x2c0000,
                        emissiveIntensity: 0.3
                    });
                    this.mesh = new THREE.Mesh(bodyGeo, bodyMat);
                    this.mesh.position.copy(position);
                    this.mesh.position.y = 4;
                    this.mesh.castShadow = true;

                    const eyeGeo = new THREE.SphereGeometry(0.6, 16, 16);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                    leftEye.position.set(-0.8, 2.5, 1.8);
                    rightEye.position.set(0.8, 2.5, 1.8);
                    this.mesh.add(leftEye);
                    this.mesh.add(rightEye);

                    const hornGeo = new THREE.ConeGeometry(0.5, 2, 8);
                    const hornMat = new THREE.MeshStandardMaterial({ color: 0x2c2c2c });
                    const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                    const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                    leftHorn.position.set(-1.5, 6, 0);
                    rightHorn.position.set(1.5, 6, 0);
                    leftHorn.rotation.z = 0.3;
                    rightHorn.rotation.z = -0.3;
                    this.mesh.add(leftHorn);
                    this.mesh.add(rightHorn);

                } else {
                    const bodyGeo = new THREE.BoxGeometry(1.5, 3, 1.5);
                    const bodyMat = new THREE.MeshStandardMaterial({
                        color: 0x8e44ad,
                        roughness: 0.3,
                        metalness: 0.7
                    });
                    this.mesh = new THREE.Mesh(bodyGeo, bodyMat);
                    this.mesh.position.copy(position);
                    this.mesh.position.y = 1.5;
                    this.mesh.castShadow = true;

                    const eyeGeo = new THREE.SphereGeometry(0.2, 8, 8);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xe74c3c });
                    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                    leftEye.position.set(-0.3, 0.8, 0.7);
                    rightEye.position.set(0.3, 0.8, 0.7);
                    this.mesh.add(leftEye);
                    this.mesh.add(rightEye);
                }

                scene.add(this.mesh);
                this.spawn();
            }

            spawn() {
                const angle = Math.random() * Math.PI * 2;
                const radius = this.isBoss ? 35 : 25 + Math.random() * 15;
                this.mesh.position.x = Math.cos(angle) * radius;
                this.mesh.position.z = Math.sin(angle) * radius;
                this.mesh.position.y = this.isBoss ? 4 : 1.5;
            }

            update(delta, playerPos) {
                if (!this.alive) return;

                const direction = new THREE.Vector3();
                direction.subVectors(playerPos, this.mesh.position);
                direction.y = 0;
                direction.normalize();

                if (this.isBoss) {
                    this.chargeCooldown -= delta;

                    if (this.chargeCooldown <= 0 && !this.isCharging && this.mesh.position.distanceTo(playerPos) < 30) {
                        this.isCharging = true;
                        this.chargeCooldown = 5;
                        this.mesh.material.emissive.setHex(0xff0000);

                        setTimeout(() => {
                            if (this.alive) {
                                this.isCharging = false;
                                this.mesh.material.emissive.setHex(0x2c0000);

                                if (this.mesh.position.distanceTo(playerPos) < 4) {
                                    takeDamage(this.damage * 2);
                                    showDamage();
                                }
                            }
                        }, 1000);
                    }
                }

                if (!this.isCharging) {
                    this.mesh.position.add(direction.multiplyScalar(this.speed * delta));
                    this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);
                }

                if (this.attackCooldown > 0) this.attackCooldown -= delta;

                const dist = this.mesh.position.distanceTo(playerPos);
                const attackRange = this.isBoss ? 4 : 2.5;
                if (dist < attackRange && this.attackCooldown <= 0 && !this.isCharging) {
                    this.attack();
                }
            }

            attack() {
                if (!gameStarted || gameOver) return;

                takeDamage(this.damage);
                this.attackCooldown = this.attackRate;
                playSound('hit');
            }

            takeDamage(amount) {
                this.health -= amount;

                if (this.isBoss) updateBossHealth();

                if (this.health <= 0) this.die();
            }

            die() {
                if (!this.alive) return;

                this.alive = false;
                createExplosion(this.mesh.position.clone(), this.isBoss ? 3 : 1);
                scene.remove(this.mesh);

                score += this.isBoss ? 1000 : 100;
                kills++;
                enemiesRemaining--;
                updateUI();
                showKillMessage(this.isBoss ? 'BOSS DEFEATED! +1000' : 'Enemy eliminated +100');

                // Drop ammo or weapon - Higher drop rates for better gameplay
                // Ammo drop: 100% chance on kill
                spawnAmmoDrop(this.mesh.position.clone());
                
                // Weapon drop: 25% chance on kill
                if (Math.random() < 0.25) {
                    spawnWeaponDrop(this.mesh.position.clone());
                }

                if (this.isBoss) updateBossHealth();

                checkWaveComplete();
            }
        }

        // Ammo Drop System
        function spawnAmmoDrop(position) {
            const types = ['pistol', 'rifle', 'shotgun', 'sniper', 'rocket'];
            const type = types[Math.floor(Math.random() * types.length)];
            const amount = weapons[type].maxAmmo;

            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshBasicMaterial({
                color: weapons[type].color,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            mesh.position.y = 1;

            // Floating animation
            scene.add(mesh);
            ammoDrops.push({ mesh, type, amount, bobOffset: Math.random() * Math.PI * 2 });

            showPickupNotification(`${weapons[type].name} Ammo +${amount}`);
            playSound('pickup');
        }

        function updateAmmoDrops(time) {
            ammoDrops.forEach((drop, index) => {
                if (!drop.mesh) return;

                drop.mesh.position.y = 1 + Math.sin(time * 2 + drop.bobOffset) * 0.3;
                drop.mesh.rotation.y += 0.02;

                const dist = drop.mesh.position.distanceTo(player.position);
                if (dist < 2.5) {
                    ammo[drop.type] = Math.min(weapons[drop.type].maxAmmo * 2, ammo[drop.type] + drop.amount);
                    totalAmmo[drop.type] += drop.amount * 3;

                    scene.remove(drop.mesh);
                    ammoDrops.splice(index, 1);
                    updateUI();
                }
            });
        }

        // Weapon Drop System
        function spawnWeaponDrop(position) {
            const types = ['rifle', 'shotgun', 'sniper', 'rocket'];
            const type = types[Math.floor(Math.random() * types.length)];

            const geo = new THREE.OctahedronGeometry(0.8, 0);
            const mat = new THREE.MeshBasicMaterial({
                color: weapons[type].color,
                wireframe: true
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            mesh.position.y = 1.5;

            scene.add(mesh);
            weaponDrops.push({ mesh, type, bobOffset: Math.random() * Math.PI * 2 });

            showPickupNotification(`NEW WEAPON: ${weapons[type].name}!`);
            playSound('pickup');
        }

        function updateWeaponDrops(time) {
            weaponDrops.forEach((drop, index) => {
                if (!drop.mesh) return;

                drop.mesh.position.y = 1.5 + Math.sin(time * 2 + drop.bobOffset) * 0.5;
                drop.mesh.rotation.y += 0.03;
                drop.mesh.rotation.x += 0.02;

                const dist = drop.mesh.position.distanceTo(player.position);
                if (dist < 2.5) {
                    currentWeapon = drop.type;
                    ammo[drop.type] = weapons[drop.type].maxAmmo;
                    totalAmmo[drop.type] = weapons[drop.type].maxAmmo * 3;

                    scene.remove(drop.mesh);
                    weaponDrops.splice(index, 1);
                    updateUI();
                    updateWeaponSlots();
                }
            });
        }

        function showPickupNotification(text) {
            const notification = document.getElementById('pickup-notification');
            notification.textContent = text;
            notification.classList.add('visible');
            setTimeout(() => notification.classList.remove('visible'), 2000);
        }

        // Explosion effect
        function createExplosion(position, size = 1) {
            const particleCount = size === 1 ? 15 : 50;
            const particles = [];
            const colors = size === 1 ? [0x8e44ad, 0xe74c3c] : [0xe74c3c, 0xf39c12, 0xc0392b, 0xff6b6b];

            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.BoxGeometry(0.3 * size, 0.3 * size, 0.3 * size);
                const mat = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)] });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 15 * size,
                    Math.random() * 12 * size,
                    (Math.random() - 0.5) * 15 * size
                );

                scene.add(particle);
                particles.push({ mesh: particle, velocity, life: 1 });
            }

            if (size > 1) {
                const ringGeo = new THREE.RingGeometry(0.5, 1, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xe74c3c, transparent: true, opacity: 1, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.copy(position);
                ring.rotation.x = -Math.PI / 2;
                scene.add(ring);

                let ringScale = 1;
                const animateRing = () => {
                    ringScale += 0.5;
                    ring.scale.setScalar(ringScale);
                    ring.material.opacity -= 0.03;

                    if (ring.material.opacity > 0) {
                        requestAnimationFrame(animateRing);
                    } else {
                        scene.remove(ring);
                        ring.geometry.dispose();
                        ring.material.dispose();
                    }
                };
                animateRing();
            }

            function animateParticles() {
                let allDead = true;

                particles.forEach(p => {
                    if (p.life > 0) {
                        allDead = false;
                        p.mesh.position.add(p.velocity.clone().multiplyScalar(0.016));
                        p.velocity.y -= 0.3;
                        p.life -= 0.016;
                        p.mesh.scale.setScalar(p.life);
                        p.mesh.rotation.x += 0.1;
                        p.mesh.rotation.y += 0.1;

                        if (p.life <= 0) {
                            scene.remove(p.mesh);
                            p.mesh.geometry.dispose();
                            p.mesh.material.dispose();
                        }
                    }
                });

                if (!allDead) requestAnimationFrame(animateParticles);
            }
            animateParticles();
        }

        // Wave System
        function startWave() {
            const isBossWave = wave % 5 === 0;

            if (isBossWave) {
                showWaveAnnouncement(`BOSS WAVE ${wave}!`);
            } else {
                showWaveAnnouncement(`WAVE ${wave}`);
            }

            if (isBossWave) {
                enemiesRemaining = 1;
                const boss = new Enemy(player.position, true);
                enemies.push(boss);

                const minionCount = Math.min(wave, 8);
                for (let i = 0; i < minionCount; i++) {
                    const minion = new Enemy(player.position, false);
                    enemies.push(minion);
                    enemiesRemaining++;
                }
            } else {
                const enemyCount = 3 + wave * 2;
                enemiesRemaining = enemyCount;

                for (let i = 0; i < enemyCount; i++) {
                    const enemy = new Enemy(player.position, false);
                    enemies.push(enemy);
                }
            }

            updateUI();
        }

        function showWaveAnnouncement(text) {
            const waveNumber = document.getElementById('wave-number');
            waveNumber.textContent = text;

            if (wave % 5 === 0) {
                waveNumber.style.color = '#e74c3c';
                waveNumber.style.fontSize = '32px';
            } else {
                waveNumber.style.color = '#f39c12';
                waveNumber.style.fontSize = '28px';
            }
        }

        function updateBossHealth() {
            const boss = enemies.find(e => e.isBoss && e.alive);
            const bossContainer = document.getElementById('boss-health-container');

            if (boss) {
                bossContainer.classList.add('visible');
                const healthPercent = (boss.health / boss.maxHealth) * 100;
                document.getElementById('boss-health-bar').style.width = `${healthPercent}%`;
            } else {
                bossContainer.classList.remove('visible');
            }
        }

        function checkWaveComplete() {
            const aliveCount = enemies.filter(e => e.alive).length;

            if (aliveCount === 0 && enemiesRemaining <= 0) {
                wave++;
                showWaveAnnouncement(`WAVE ${wave}`);
                setTimeout(() => startWave(), 3000);
            }
        }

        // Shooting
        function shoot() {
            if (!gameStarted || gameOver || isReloading) {
                if (ammo[currentWeapon] <= 0 && !isReloading) {
                    playSound('empty');
                }
                return;
            }

            const now = performance.now();
            const weaponData = weapons[currentWeapon];

            if (now - lastShotTime < weaponData.fireRate) return;
            lastShotTime = now;

            if (ammo[currentWeapon] <= 0) {
                reload();
                return;
            }

            ammo[currentWeapon]--;
            updateUI();
            playSound('shoot', currentWeapon);

            const flash = document.getElementById('muzzleFlash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 50);

            const crosshair = document.getElementById('crosshair');
            crosshair.classList.add('spread');
            setTimeout(() => crosshair.classList.remove('spread'), weaponData.fireRate);

            // Handle different weapon types
            if (currentWeapon === 'shotgun') {
                // Shotgun fires multiple pellets
                for (let i = 0; i < weaponData.pellets; i++) {
                    fireShotgunPellet(weaponData);
                }
            } else if (currentWeapon === 'rocket') {
                // Rocket launcher fires explosive projectile
                fireRocket();
            } else {
                // Regular shot
                fireRegularShot(weaponData);
            }
        }

        function fireRegularShot(weaponData) {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(
                (Math.random() - 0.5) * weaponData.spread,
                (Math.random() - 0.5) * weaponData.spread
            ), camera);
            raycaster.far = 100;

            createBulletTrail(null, weaponData.color);

            const enemyMeshes = enemies.filter(e => e.alive).map(e => e.mesh);
            const intersects = raycaster.intersectObjects(enemyMeshes, true);

            if (intersects.length > 0) {
                showHitMarker();

                const hitMesh = intersects[0].object;
                const hitEnemy = enemies.find(e => e.alive && (e.mesh === hitMesh || e.mesh.children.includes(hitMesh)));

                if (hitEnemy) {
                    hitEnemy.takeDamage(weaponData.damage);
                    playSound('hit');

                    if (hitMesh.material) {
                        const originalColor = hitMesh.material.color.getHex();
                        hitMesh.material.color.setHex(0xff0000);
                        setTimeout(() => {
                            if (hitMesh.material) hitMesh.material.color.setHex(originalColor);
                        }, 100);
                    }
                }
            }
        }

        function fireShotgunPellet(weaponData) {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(
                (Math.random() - 0.5) * weaponData.spread,
                (Math.random() - 0.5) * weaponData.spread
            ), camera);
            raycaster.far = 50;

            const enemyMeshes = enemies.filter(e => e.alive).map(e => e.mesh);
            const intersects = raycaster.intersectObjects(enemyMeshes, true);

            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                const hitEnemy = enemies.find(e => e.alive && (e.mesh === hitMesh || e.mesh.children.includes(hitMesh)));

                if (hitEnemy) {
                    hitEnemy.takeDamage(weaponData.damage);
                }
            }
        }

        function fireRocket() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 200;

            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            // Create rocket mesh
            const rocketGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const rocketMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const rocket = new THREE.Mesh(rocketGeo, rocketMat);
            rocket.position.copy(camera.position);
            rocket.position.y -= 0.5;
            rocket.rotation.x = Math.PI / 2;
            scene.add(rocket);

            // Trail
            const trailGeo = new THREE.CylinderGeometry(0.1, 0.15, 2, 8);
            const trailMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 });
            const trail = new THREE.Mesh(trailGeo, trailMat);
            trail.position.y = -1.5;
            rocket.add(trail);

            let traveled = 0;
            const speed = 50;

            const flyRocket = () => {
                const delta = 0.016;
                traveled += speed * delta;

                if (traveled > 200) {
                    scene.remove(rocket);
                    playSound('explosion');
                    createExplosion(rocket.position, 2);
                    damageEnemiesInRadius(rocket.position, 10, 200);
                    return;
                }

                rocket.position.add(direction.clone().multiplyScalar(speed * delta));

                // Check wall collision
                for (const wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    if (wallBox.containsPoint(rocket.position)) {
                        scene.remove(rocket);
                        playSound('explosion');
                        createExplosion(rocket.position, 2);
                        damageEnemiesInRadius(rocket.position, 10, 200);
                        return;
                    }
                }

                requestAnimationFrame(flyRocket);
            };
            flyRocket();
        }

        function damageEnemiesInRadius(position, radius, damage) {
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    const dist = enemy.mesh.position.distanceTo(position);
                    if (dist < radius) {
                        enemy.takeDamage(damage * (1 - dist / radius));
                    }
                }
            });
        }

        function showHitMarker() {
            const hitMarker = document.getElementById('crosshair');
            hitMarker.style.opacity = '1';
            setTimeout(() => hitMarker.style.opacity = '0', 50);
        }

        function createBulletTrail(hitPoint, color) {
            const gunPos = camera.position.clone();
            gunPos.y -= 1;
            gunPos.add(new THREE.Vector3(0.5, -0.3, -1).applyQuaternion(camera.quaternion));

            const endPos = hitPoint || gunPos.clone().add(new THREE.Vector3(0, 0, -100).applyQuaternion(camera.quaternion));

            const points = [gunPos, endPos];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color || 0xffff00, transparent: true, opacity: 0.8 });

            const trail = new THREE.Line(geometry, material);
            scene.add(trail);

            setTimeout(() => {
                scene.remove(trail);
                geometry.dispose();
                material.dispose();
            }, 50);
        }

        function reload() {
            const weaponData = weapons[currentWeapon];

            if (isReloading || ammo[currentWeapon] === weaponData.maxAmmo || totalAmmo[currentWeapon] <= 0) return;

            isReloading = true;
            document.getElementById('reload-indicator').classList.add('visible');
            playSound('reload');

            setTimeout(() => {
                const needed = weaponData.maxAmmo - ammo[currentWeapon];
                const available = Math.min(needed, totalAmmo[currentWeapon]);
                ammo[currentWeapon] += available;
                totalAmmo[currentWeapon] -= available;
                isReloading = false;
                document.getElementById('reload-indicator').classList.remove('visible');
                updateUI();
            }, 1500);
        }

        function switchWeapon(index) {
            const weaponNames = ['pistol', 'rifle', 'shotgun', 'sniper', 'rocket'];
            if (index >= 1 && index <= 5) {
                const oldWeapon = currentWeapon;
                currentWeapon = weaponNames[index - 1];
                console.log(`Switched from ${oldWeapon} to ${currentWeapon}`);
                playSound('pickup');
                updateUI();
                updateWeaponSlots();
            }
        }

        function updateWeaponSlots() {
            const weaponNames = ['pistol', 'rifle', 'shotgun', 'sniper', 'rocket'];
            weaponNames.forEach((name, index) => {
                const slot = document.getElementById(`slot-${index + 1}`);
                if (name === currentWeapon) {
                    slot.classList.add('active');
                } else {
                    slot.classList.remove('active');
                }
            });
        }

        function takeDamage(amount) {
            health -= amount;
            playSound('damage');

            if (health <= 0) {
                health = 0;
                endGame();
            }

            updateUI();
        }

        function showDamage() {
            const overlay = document.getElementById('damageOverlay');
            overlay.style.opacity = '1';
            setTimeout(() => overlay.style.opacity = '0', 200);
        }

        function updateUI() {
            const weaponData = weapons[currentWeapon];

            document.getElementById('health-bar').style.width = `${(health / maxHealth) * 100}%`;
            document.getElementById('health-text').textContent = `${Math.ceil(health)} / ${maxHealth}`;
            document.getElementById('weapon-name').textContent = weaponData.name;
            document.getElementById('ammo-display').textContent = `${ammo[currentWeapon]} / ${totalAmmo[currentWeapon]}`;
            document.getElementById('score').textContent = score;
            document.getElementById('kills').textContent = `${kills} KILLS`;
            document.getElementById('wave-number').textContent = wave % 5 === 0 ? `BOSS WAVE ${wave}` : `WAVE ${wave}`;
            document.getElementById('enemies-remaining').textContent = `Enemies: ${enemiesRemaining}`;
        }

        function showKillMessage(customText = 'Enemy eliminated +100') {
            const feed = document.getElementById('killFeed');
            const msg = document.createElement('div');
            msg.className = 'kill-message';
            msg.textContent = customText;
            msg.style.color = customText.includes('BOSS') ? '#e74c3c' : '#fff';
            feed.appendChild(msg);

            setTimeout(() => {
                msg.style.opacity = '0';
                setTimeout(() => msg.remove(), 500);
            }, 2000);
        }

        // Physics
        function checkCollision(newPos) {
            const playerRadius = 0.5;
            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - playerRadius, 0, newPos.z - playerRadius),
                new THREE.Vector3(newPos.x + playerRadius, 4, newPos.z + playerRadius)
            );

            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) return true;
            }

            return false;
        }

        // Game Loop
        const clock = new THREE.Clock();

        function update() {
            if (!gameStarted || gameOver) return;

            const delta = Math.min(clock.getDelta(), 0.1);
            const time = performance.now() / 1000;

            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            if (moveState.forward) direction.add(forward);
            if (moveState.backward) direction.sub(forward);
            if (moveState.left) direction.sub(right);
            if (moveState.right) direction.add(right);
            direction.normalize();

            player.velocity.x = direction.x * player.speed;
            player.velocity.z = direction.z * player.speed;
            player.velocity.y -= 30 * delta;

            const newPos = player.position.clone();
            newPos.x += player.velocity.x * delta;
            newPos.y += player.velocity.y * delta;
            newPos.z += player.velocity.z * delta;

            if (!checkCollision(new THREE.Vector3(newPos.x, player.position.y, player.position.z))) {
                player.position.x = newPos.x;
            }
            if (!checkCollision(new THREE.Vector3(player.position.x, player.position.y, newPos.z))) {
                player.position.z = newPos.z;
            }

            if (newPos.y <= 2) {
                newPos.y = 2;
                player.velocity.y = 0;
                player.onGround = true;
            }

            player.position.copy(newPos);
            camera.position.copy(player.position);
            camera.position.y = 2;

            // Auto-fire for automatic weapons
            if (moveState.shoot && weapons[currentWeapon].auto) {
                shoot();
            }

            enemies.forEach(enemy => enemy.update(delta, player.position));
            updateAmmoDrops(time);
            updateWeaponDrops(time);
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            initAudio();
            createArena();
            setupLighting();
            setupControls();

            gameStarted = true;
            gameOver = false;
            score = 0;
            kills = 0;
            wave = 1;
            health = maxHealth;
            enemies = [];
            ammoDrops = [];
            weaponDrops = [];
            currentWeapon = 'pistol';

            // Reset ammo
            Object.keys(weapons).forEach(w => {
                ammo[w] = weapons[w].maxAmmo;
                totalAmmo[w] = weapons[w].maxAmmo * 3;
            });

            startWave();
            updateUI();
            updateWeaponSlots();
            canvas.requestPointerLock();
        }

        function endGame() {
            gameOver = true;
            document.exitPointerLock();

            document.getElementById('gameOverScreen').style.display = 'flex';
            document.getElementById('gameOverScreen').querySelector('#final-score').textContent = `Final Score: ${score}`;
            document.getElementById('hud').style.display = 'none';
        }

        function restartGame() {
            enemies.forEach(e => { if (e.alive) scene.remove(e.mesh); });
            enemies = [];
            ammoDrops.forEach(d => scene.remove(d.mesh));
            ammoDrops = [];
            weaponDrops.forEach(d => scene.remove(d.mesh));
            weaponDrops = [];

            player.position.set(0, 2, 0);
            player.velocity.set(0, 0, 0);

            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            gameOver = false;
            score = 0;
            kills = 0;
            wave = 1;
            health = maxHealth;
            currentWeapon = 'pistol';

            Object.keys(weapons).forEach(w => {
                ammo[w] = weapons[w].maxAmmo;
                totalAmmo[w] = weapons[w].maxAmmo * 3;
            });

            startWave();
            updateUI();
            updateWeaponSlots();
            canvas.requestPointerLock();
        }

        function setupControls() {
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameStarted && !gameOver) {
                    moveState.shoot = true;
                    if (!weapons[currentWeapon].auto) shoot();
                }
            });

            canvas.addEventListener('mouseup', () => {
                moveState.shoot = false;
            });

            canvas.addEventListener('click', () => {
                if (gameStarted && !gameOver) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('mousemove', (event) => {
                if (!gameStarted || gameOver || document.pointerLockElement !== canvas) return;

                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                euler.setFromQuaternion(camera.quaternion);
                euler.y -= movementX * 0.002;
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                camera.quaternion.setFromEuler(euler);
            });

            document.addEventListener('keydown', (event) => {
                if (!gameStarted || gameOver) return;

                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': moveState.forward = true; break;
                    case 'KeyS': case 'ArrowDown': moveState.backward = true; break;
                    case 'KeyA': case 'ArrowLeft': moveState.left = true; break;
                    case 'KeyD': case 'ArrowRight': moveState.right = true; break;
                    case 'Space':
                        if (player.onGround) {
                            player.velocity.y = player.jumpForce;
                            player.onGround = false;
                        }
                        break;
                    case 'KeyR': reload(); break;
                    case 'Digit1': switchWeapon(1); break;
                    case 'Digit2': switchWeapon(2); break;
                    case 'Digit3': switchWeapon(3); break;
                    case 'Digit4': switchWeapon(4); break;
                    case 'Digit5': switchWeapon(5); break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': moveState.forward = false; break;
                    case 'KeyS': case 'ArrowDown': moveState.backward = false; break;
                    case 'KeyA': case 'ArrowLeft': moveState.left = false; break;
                    case 'KeyD': case 'ArrowRight': moveState.right = false; break;
                }
            });
        }

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', restartGame);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
