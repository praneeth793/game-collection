<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Protocol - FPS Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            cursor: none;
        }

        /* HUD Styles */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Health Bar */
        #health-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 250px;
        }

        #health-label {
            color: #fff;
            font-size: 14px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #health-bar-bg {
            width: 100%;
            height: 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #444;
            border-radius: 4px;
            overflow: hidden;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            transition: width 0.3s ease;
        }

        #health-text {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            margin-top: 5px;
            text-align: right;
        }

        /* Boss Health Bar */
        #boss-health-container {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            display: none;
        }

        #boss-health-container.visible {
            display: block;
        }

        #boss-name {
            color: #e74c3c;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-align: center;
            margin-bottom: 5px;
            text-shadow: 0 0 10px #e74c3c;
            animation: bossPulse 1s infinite;
        }

        @keyframes bossPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #boss-health-bar-bg {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #e74c3c;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        #boss-health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #c0392b, #e74c3c, #ff6b6b);
            transition: width 0.2s ease;
        }

        /* Ammo Display */
        #ammo-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
        }

        #ammo-display {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #ammo-label {
            color: #aaa;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #reload-indicator {
            color: #f39c12;
            font-size: 16px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        #reload-indicator.visible {
            opacity: 1;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            50% { opacity: 0.5; }
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair.dot::after {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #e74c3c;
        }

        /* Score */
        #score-container {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
        }

        #score {
            font-size: 32px;
            color: #fff;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #kills {
            color: #aaa;
            font-size: 14px;
        }

        /* Wave Info */
        #wave-container {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        #wave-number {
            font-size: 28px;
            color: #f39c12;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #enemies-remaining {
            color: #aaa;
            font-size: 14px;
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
        }

        #startScreen h1 {
            color: #e74c3c;
            font-size: 4rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.5rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(231, 76, 60, 0.5);
        }

        #startScreen h2 {
            color: #fff;
            font-size: 1.5rem;
            font-weight: 300;
            margin-bottom: 3rem;
            letter-spacing: 0.3rem;
        }

        #startScreen .instructions {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 2rem;
            text-align: center;
            line-height: 2;
        }

        #startScreen .start-btn {
            padding: 15px 50px;
            font-size: 1.2rem;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        #startScreen .start-btn:hover {
            background: #c0392b;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(231, 76, 60, 0.5);
        }

        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #gameOverScreen h1 {
            color: #e74c3c;
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 1rem;
        }

        #final-score {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }

        #restartBtn {
            padding: 15px 50px;
            font-size: 1.2rem;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s ease;
        }

        #restartBtn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        /* Damage overlay */
        #damageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(139, 0, 0, 0.6) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            transition: opacity 0.1s;
        }

        /* Muzzle flash */
        #muzzleFlash {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100px;
            height: 100px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(255, 200, 100, 0.8) 0%, transparent 70%);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
        }

        /* Kill feed */
        #killFeed {
            position: absolute;
            top: 80px;
            right: 20px;
            text-align: right;
        }

        .kill-message {
            color: #fff;
            font-size: 14px;
            margin-bottom: 5px;
            opacity: 1;
            transition: opacity 0.5s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div id="crosshair" class="dot"></div>
        <div id="damageOverlay"></div>
        <div id="muzzleFlash"></div>

        <div id="wave-container">
            <div id="wave-number">WAVE 1</div>
            <div id="enemies-remaining">Enemies: 0</div>
        </div>

        <div id="score-container">
            <div id="score">0</div>
            <div id="kills">0 KILLS</div>
        </div>

        <div id="health-container">
            <div id="health-label">Health</div>
            <div id="health-bar-bg">
                <div id="health-bar"></div>
            </div>
            <div id="health-text">100 / 100</div>
        </div>

        <div id="boss-health-container">
            <div id="boss-name">⚔️ TITAN OVERLORD ⚔️</div>
            <div id="boss-health-bar-bg">
                <div id="boss-health-bar"></div>
            </div>
        </div>

        <div id="ammo-container">
            <div id="ammo-display">30 / 90</div>
            <div id="ammo-label">AMMO</div>
            <div id="reload-indicator">[R] RELOADING...</div>
        </div>

        <div id="killFeed"></div>
        <div id="hitMarker" style="
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            opacity: 0;
            z-index: 20;
        ">
            <div style="
                position: absolute;
                top: 50%;
                left: 50%;
                width: 12px;
                height: 12px;
                transform: translate(-50%, -50%) rotate(45deg);
                border: 2px solid #e74c3c;
                box-shadow: 0 0 10px #e74c3c;
            "></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen">
        <h1>Shadow Protocol</h1>
        <h2>FPS Arena</h2>
        <div class="instructions">
            <p>WASD - Move | MOUSE - Aim | CLICK - Shoot</p>
            <p>R - Reload | SPACE - Jump</p>
            <p>Eliminate all enemies to survive!</p>
        </div>
        <button class="start-btn" id="startBtn">CLICK TO START</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1>MISSION FAILED</h1>
        <div id="final-score">Final Score: 0</div>
        <button id="restartBtn">TRY AGAIN</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Game State
        let gameStarted = false;
        let gameOver = false;
        let score = 0;
        let kills = 0;
        let wave = 1;
        let enemiesRemaining = 0;
        let health = 100;
        const maxHealth = 100;
        let ammo = 30;
        const maxAmmo = 30;
        let totalAmmo = 90;
        let isReloading = false;
        let lastShotTime = 0;
        const fireRate = 100;

        // Player
        let player = {
            position: new THREE.Vector3(0, 2, 0),
            velocity: new THREE.Vector3(),
            onGround: true,
            speed: 15,
            jumpForce: 15
        };

        // Controls
        let moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;

        // Three.js
        const canvas = document.getElementById('gameCanvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.FogExp2(0x1a1a2e, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(player.position);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Audio
        let audioCtx;
        let masterGain;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);
        }

        function playSound(type) {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            switch(type) {
                case 'shoot':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    break;
                case 'hit':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    break;
                case 'reload':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                    osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    break;
                case 'empty':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                    break;
                case 'damage':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    break;
            }

            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        // Arena Environment
        const arenaSize = 80;
        const walls = [];
        const enemies = [];
        const pickups = [];

        function createArena() {
            // Floor
            const floorGeo = new THREE.PlaneGeometry(arenaSize, arenaSize, 20, 20);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x2c3e50,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Grid on floor
            const gridHelper = new THREE.GridHelper(arenaSize, 40, 0x34495e, 0x2c3e50);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Walls
            const wallGeo = new THREE.BoxGeometry(arenaSize, 15, 2);
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0x34495e,
                roughness: 0.5,
                metalness: 0.3
            });

            // Create 4 walls
            for (let i = 0; i < 4; i++) {
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.y = 7.5;
                
                if (i < 2) {
                    wall.position.z = (i === 0 ? 1 : -1) * arenaSize / 2;
                } else {
                    wall.position.z = 0;
                    wall.rotation.y = Math.PI / 2;
                    wall.position.x = (i === 2 ? 1 : -1) * arenaSize / 2;
                }
                
                wall.castShadow = true;
                wall.receiveShadow = true;
                walls.push(wall);
                scene.add(wall);
            }

            // Cover structures
            const coverPositions = [
                { x: -20, z: -20 },
                { x: 20, z: -20 },
                { x: -20, z: 20 },
                { x: 20, z: 20 },
                { x: 0, z: -15 },
                { x: 0, z: 15 },
                { x: -15, z: 0 },
                { x: 15, z: 0 }
            ];

            coverPositions.forEach(pos => {
                const coverGeo = new THREE.BoxGeometry(8, 6, 4);
                const cover = new THREE.Mesh(coverGeo, wallMat);
                cover.position.set(pos.x, 3, pos.z);
                cover.castShadow = true;
                cover.receiveShadow = true;
                walls.push(cover);
                scene.add(cover);
            });

            // Pillars
            const pillarGeo = new THREE.CylinderGeometry(1, 1, 12, 16);
            const pillarPositions = [
                { x: -30, z: -30 },
                { x: 30, z: -30 },
                { x: -30, z: 30 },
                { x: 30, z: 30 }
            ];

            pillarPositions.forEach(pos => {
                const pillar = new THREE.Mesh(pillarGeo, wallMat);
                pillar.position.set(pos.x, 6, pos.z);
                pillar.castShadow = true;
                pillar.receiveShadow = true;
                walls.push(pillar);
                scene.add(pillar);
            });
        }

        // Lighting
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Main light
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(30, 50, 30);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 150;
            mainLight.shadow.camera.left = -50;
            mainLight.shadow.camera.right = 50;
            mainLight.shadow.camera.top = 50;
            mainLight.shadow.camera.bottom = -50;
            scene.add(mainLight);

            // Colored accent lights
            const colors = [0xe74c3c, 0x3498db, 0xf39c12];
            colors.forEach((color, i) => {
                const light = new THREE.PointLight(color, 0.5, 40);
                const angle = (i / 3) * Math.PI * 2;
                light.position.set(
                    Math.cos(angle) * 25,
                    10,
                    Math.sin(angle) * 25
                );
                scene.add(light);
            });
        }

        // Enemy Class
        class Enemy {
            constructor(position, isBoss = false) {
                this.isBoss = isBoss;
                this.health = isBoss ? 300 : 50;
                this.maxHealth = this.health;
                this.speed = isBoss ? 5 : 8;
                this.damage = isBoss ? 20 : 10;
                this.attackCooldown = 0;
                this.attackRate = isBoss ? 0.8 : 1;
                this.alive = true;
                this.chargeCooldown = 0;
                this.isCharging = false;
                this.chargeTarget = null;

                // Create mesh
                if (isBoss) {
                    // Boss is much larger
                    const bodyGeo = new THREE.BoxGeometry(4, 8, 4);
                    const bodyMat = new THREE.MeshStandardMaterial({
                        color: 0xc0392b,
                        roughness: 0.2,
                        metalness: 0.9,
                        emissive: 0x2c0000,
                        emissiveIntensity: 0.3
                    });
                    this.mesh = new THREE.Mesh(bodyGeo, bodyMat);
                    this.mesh.position.copy(position);
                    this.mesh.position.y = 4;
                    this.mesh.castShadow = true;

                    // Boss eyes (glowing)
                    const eyeGeo = new THREE.SphereGeometry(0.6, 16, 16);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                    leftEye.position.set(-0.8, 2.5, 1.8);
                    rightEye.position.set(0.8, 2.5, 1.8);
                    this.mesh.add(leftEye);
                    this.mesh.add(rightEye);

                    // Boss horns
                    const hornGeo = new THREE.ConeGeometry(0.5, 2, 8);
                    const hornMat = new THREE.MeshStandardMaterial({ color: 0x2c2c2c });
                    const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                    const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                    leftHorn.position.set(-1.5, 6, 0);
                    rightHorn.position.set(1.5, 6, 0);
                    leftHorn.rotation.z = 0.3;
                    rightHorn.rotation.z = -0.3;
                    this.mesh.add(leftHorn);
                    this.mesh.add(rightHorn);

                    // Boss armor plates
                    const armorGeo = new THREE.BoxGeometry(4.2, 2, 4.2);
                    const armorMat = new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a,
                        roughness: 0.5,
                        metalness: 0.8
                    });
                    const armor = new THREE.Mesh(armorGeo, armorMat);
                    armor.position.y = -1;
                    this.mesh.add(armor);

                } else {
                    // Regular enemy
                    const bodyGeo = new THREE.BoxGeometry(1.5, 3, 1.5);
                    const bodyMat = new THREE.MeshStandardMaterial({
                        color: 0x8e44ad,
                        roughness: 0.3,
                        metalness: 0.7
                    });
                    this.mesh = new THREE.Mesh(bodyGeo, bodyMat);
                    this.mesh.position.copy(position);
                    this.mesh.position.y = 1.5;
                    this.mesh.castShadow = true;

                    // Eyes
                    const eyeGeo = new THREE.SphereGeometry(0.2, 8, 8);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xe74c3c });
                    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                    leftEye.position.set(-0.3, 0.8, 0.7);
                    rightEye.position.set(0.3, 0.8, 0.7);
                    this.mesh.add(leftEye);
                    this.mesh.add(rightEye);
                }

                scene.add(this.mesh);
                this.spawn();
            }

            spawn() {
                const angle = Math.random() * Math.PI * 2;
                const radius = this.isBoss ? 35 : 25 + Math.random() * 15;
                this.mesh.position.x = Math.cos(angle) * radius;
                this.mesh.position.z = Math.sin(angle) * radius;
                this.mesh.position.y = this.isBoss ? 4 : 1.5;
            }

            update(delta, playerPos) {
                if (!this.alive) return;

                const direction = new THREE.Vector3();
                direction.subVectors(playerPos, this.mesh.position);
                direction.y = 0;
                direction.normalize();

                // Boss special: Charge attack every 5 seconds
                if (this.isBoss) {
                    this.chargeCooldown -= delta;

                    // Start charge
                    if (this.chargeCooldown <= 0 && !this.isCharging && this.mesh.position.distanceTo(playerPos) < 30) {
                        this.isCharging = true;
                        this.chargeTarget = playerPos.clone();
                        this.mesh.material.emissive.setHex(0xff0000);
                        this.mesh.material.emissiveIntensity = 0.8;

                        // Telegraph charge
                        setTimeout(() => {
                            if (this.alive) {
                                const chargeDir = this.chargeTarget.clone().sub(this.mesh.position).normalize();
                                const chargeSpeed = 25;
                                const endPos = this.mesh.position.clone().add(chargeDir.multiplyScalar(50));

                                // Animate charge
                                const chargeDuration = 0.5;
                                const startPos = this.mesh.position.clone();
                                const startTime = performance.now();

                                const animateCharge = () => {
                                    const elapsed = (performance.now() - startTime) / 1000;
                                    if (elapsed < chargeDuration) {
                                        const t = elapsed / chargeDuration;
                                        this.mesh.position.lerpVectors(startPos, endPos, t);
                                        this.mesh.lookAt(this.chargeTarget);
                                        requestAnimationFrame(animateCharge);
                                    } else {
                                        this.isCharging = false;
                                        this.chargeCooldown = 5;
                                        this.mesh.material.emissive.setHex(0x2c0000);
                                        this.mesh.material.emissiveIntensity = 0.3;

                                        // Check if hit player
                                        if (this.mesh.position.distanceTo(playerPos) < 4) {
                                            takeDamage(this.damage * 2);
                                            showDamage();
                                        }
                                    }
                                };
                                animateCharge();
                            }
                        }, 1000);
                    }
                }

                if (!this.isCharging) {
                    // Move towards player
                    this.mesh.position.add(direction.multiplyScalar(this.speed * delta));

                    // Look at player
                    this.mesh.lookAt(playerPos.x, this.mesh.position.y, playerPos.z);
                }

                // Attack cooldown
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }

                // Attack player if close
                const dist = this.mesh.position.distanceTo(playerPos);
                const attackRange = this.isBoss ? 4 : 2.5;
                if (dist < attackRange && this.attackCooldown <= 0 && !this.isCharging) {
                    this.attack();
                }
            }

            attack() {
                if (!gameStarted || gameOver) return;

                takeDamage(this.damage);
                this.attackCooldown = this.attackRate;
                playSound('hit');

                // Visual feedback
                showDamage();
            }

            takeDamage(amount) {
                this.health -= amount;

                // Update boss health bar
                if (this.isBoss) {
                    updateBossHealth();
                }

                if (this.health <= 0) {
                    this.die();
                }
            }

            die() {
                this.alive = false;

                // Create explosion effect
                const explosionSize = this.isBoss ? 3 : 1;
                createExplosion(this.mesh.position.clone(), explosionSize);

                scene.remove(this.mesh);

                // Boss gives 1000 points, regular enemy gives 100
                score += this.isBoss ? 1000 : 100;
                kills++;
                enemiesRemaining--;
                updateUI();
                showKillMessage(this.isBoss ? 'BOSS DEFEATED! +1000' : 'Enemy eliminated +100');

                // Hide boss health bar
                if (this.isBoss) {
                    updateBossHealth();
                }

                // Check if wave is complete
                checkWaveComplete();

                // Spawn health pickup occasionally
                if (Math.random() < 0.3) {
                    spawnPickup(this.mesh.position.clone(), 'health');
                }
            }
        }

        // Explosion effect
        function createExplosion(position, size = 1) {
            const particleCount = size === 1 ? 15 : 50;
            const particles = [];

            // Boss explosion has more colors
            const colors = size === 1 ?
                [0x8e44ad, 0xe74c3c] :
                [0xe74c3c, 0xf39c12, 0xc0392b, 0x8e44ad, 0xff6b6b];

            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.BoxGeometry(0.3 * size, 0.3 * size, 0.3 * size);
                const mat = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 15 * size,
                    Math.random() * 12 * size,
                    (Math.random() - 0.5) * 15 * size
                );

                scene.add(particle);
                particles.push({ mesh: particle, velocity, life: 1 });
            }

            // Boss explosion also creates a shockwave ring
            if (size > 1) {
                const ringGeo = new THREE.RingGeometry(0.5, 1, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xe74c3c,
                    transparent: true,
                    opacity: 1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.copy(position);
                ring.rotation.x = -Math.PI / 2;
                scene.add(ring);

                // Animate ring
                let ringScale = 1;
                const animateRing = () => {
                    ringScale += 0.5;
                    ring.scale.setScalar(ringScale);
                    ring.material.opacity -= 0.03;

                    if (ring.material.opacity > 0) {
                        requestAnimationFrame(animateRing);
                    } else {
                        scene.remove(ring);
                        ring.geometry.dispose();
                        ring.material.dispose();
                    }
                };
                animateRing();
            }

            // Animate particles
            function animateParticles() {
                let allDead = true;

                particles.forEach(p => {
                    if (p.life > 0) {
                        allDead = false;
                        p.mesh.position.add(p.velocity.clone().multiplyScalar(0.016));
                        p.velocity.y -= 0.3; // Gravity
                        p.life -= 0.016;
                        p.mesh.scale.setScalar(p.life);
                        p.mesh.rotation.x += 0.1;
                        p.mesh.rotation.y += 0.1;

                        if (p.life <= 0) {
                            scene.remove(p.mesh);
                            p.mesh.geometry.dispose();
                            p.mesh.material.dispose();
                        }
                    }
                });

                if (!allDead) {
                    requestAnimationFrame(animateParticles);
                }
            }

            animateParticles();
        }

        // Pickup System
        function spawnPickup(position, type) {
            const geo = new THREE.OctahedronGeometry(0.5, 0);
            const mat = new THREE.MeshBasicMaterial({
                color: type === 'health' ? 0x2ecc71 : 0xf39c12
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            mesh.position.y = 1;

            scene.add(mesh);

            pickups.push({
                mesh,
                type,
                bobOffset: Math.random() * Math.PI * 2
            });
        }

        function updatePickups(time) {
            pickups.forEach((pickup, index) => {
                if (!pickup.mesh) return;

                // Bob animation
                pickup.mesh.position.y = 1 + Math.sin(time * 3 + pickup.bobOffset) * 0.3;
                pickup.mesh.rotation.y += 0.02;

                // Check player collision
                const dist = pickup.mesh.position.distanceTo(player.position);
                if (dist < 2) {
                    if (pickup.type === 'health') {
                        health = Math.min(maxHealth, health + 25);
                        updateUI();
                    } else if (pickup.type === 'ammo') {
                        totalAmmo += 30;
                        updateUI();
                    }

                    scene.remove(pickup.mesh);
                    pickups.splice(index, 1);
                }
            });
        }

        // Hit marker
        function showHitMarker() {
            const hitMarker = document.getElementById('hitMarker');
            hitMarker.style.opacity = '1';
            setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 100);
        }

        // Bullet trail
        function createBulletTrail(hitPoint) {
            // Get gun position (below camera)
            const gunPos = camera.position.clone();
            gunPos.y -= 1;
            gunPos.add(new THREE.Vector3(0.5, -0.3, -1).applyQuaternion(camera.quaternion));

            // Create trail geometry
            const endPos = hitPoint || gunPos.clone().add(
                new THREE.Vector3(0, 0, -100).applyQuaternion(camera.quaternion)
            );

            const points = [gunPos, endPos];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });

            const trail = new THREE.Line(geometry, material);
            scene.add(trail);

            // Remove trail after short time
            setTimeout(() => {
                scene.remove(trail);
                geometry.dispose();
                material.dispose();
            }, 50);
        }

        // Wave System
        function startWave() {
            const isBossWave = wave % 5 === 0;

            // Show wave announcement
            if (isBossWave) {
                showWaveAnnouncement(`BOSS WAVE ${wave}!`);
            } else {
                showWaveAnnouncement(`WAVE ${wave}`);
            }

            if (isBossWave) {
                // Boss wave - spawn one powerful boss
                enemiesRemaining = 1;
                const boss = new Enemy(player.position, true);
                enemies.push(boss);

                // Add some minions
                const minionCount = Math.min(wave, 8);
                for (let i = 0; i < minionCount; i++) {
                    const minion = new Enemy(player.position, false);
                    enemies.push(minion);
                    enemiesRemaining++;
                }
            } else {
                // Regular wave
                const enemyCount = 3 + wave * 2;
                enemiesRemaining = enemyCount;

                for (let i = 0; i < enemyCount; i++) {
                    const enemy = new Enemy(player.position, false);
                    enemies.push(enemy);
                }
            }

            updateUI();
        }

        function showWaveAnnouncement(text) {
            const waveContainer = document.getElementById('wave-container');
            const waveNumber = document.getElementById('wave-number');
            waveNumber.textContent = text;

            if (wave % 5 === 0) {
                waveNumber.style.color = '#e74c3c';
                waveNumber.style.fontSize = '32px';
                waveNumber.style.textShadow = '0 0 20px #e74c3c';
            } else {
                waveNumber.style.color = '#f39c12';
                waveNumber.style.fontSize = '28px';
                waveNumber.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.8)';
            }
        }

        function updateBossHealth() {
            const boss = enemies.find(e => e.isBoss && e.alive);
            const bossContainer = document.getElementById('boss-health-container');

            if (boss) {
                bossContainer.classList.add('visible');
                const bossHealthBar = document.getElementById('boss-health-bar');
                const healthPercent = (boss.health / boss.maxHealth) * 100;
                bossHealthBar.style.width = `${healthPercent}%`;
            } else {
                bossContainer.classList.remove('visible');
            }
        }

        function checkWaveComplete() {
            // Remove dead enemies from array
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (!enemies[i].alive) {
                    enemies.splice(i, 1);
                }
            }

            if (enemiesRemaining <= 0 && enemies.length === 0) {
                wave++;
                showWaveAnnouncement(`WAVE ${wave}`);
                setTimeout(() => startWave(), 3000);
            }
        }

        // Shooting
        function shoot() {
            if (!gameStarted || gameOver || isReloading) {
                if (ammo <= 0 && !isReloading) {
                    playSound('empty');
                }
                return;
            }

            const now = performance.now();
            if (now - lastShotTime < fireRate) return;
            lastShotTime = now;

            if (ammo <= 0) {
                reload();
                return;
            }

            ammo--;
            updateUI();
            playSound('shoot');

            // Muzzle flash
            const flash = document.getElementById('muzzleFlash');
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 50);

            // Raycasting
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 100;

            // Get all enemy meshes
            const enemyMeshes = enemies
                .filter(enemy => enemy.alive)
                .map(enemy => enemy.mesh);

            // Check for hits
            const intersects = raycaster.intersectObjects(enemyMeshes, true);

            // Create bullet trail
            createBulletTrail(intersects.length > 0 ? intersects[0].point : null);

            if (intersects.length > 0) {
                // Show hit marker
                showHitMarker();

                // Find which enemy was hit
                const hitMesh = intersects[0].object;
                const hitEnemy = enemies.find(enemy => enemy.alive && (enemy.mesh === hitMesh || enemy.mesh.children.includes(hitMesh)));

                if (hitEnemy) {
                    hitEnemy.takeDamage(34); // 3 shots to kill (34*3=102 > 100)
                    playSound('hit');

                    // Flash enemy red
                    if (hitMesh.material) {
                        const originalColor = hitMesh.material.color.getHex();
                        hitMesh.material.color.setHex(0xff0000);
                        setTimeout(() => {
                            if (hitMesh.material) hitMesh.material.color.setHex(originalColor);
                        }, 100);
                    }
                }
            }
        }

        // Reload
        function reload() {
            if (isReloading || ammo === maxAmmo || totalAmmo <= 0) return;

            isReloading = true;
            document.getElementById('reload-indicator').classList.add('visible');
            playSound('reload');

            setTimeout(() => {
                const needed = maxAmmo - ammo;
                const available = Math.min(needed, totalAmmo);
                ammo += available;
                totalAmmo -= available;
                isReloading = false;
                document.getElementById('reload-indicator').classList.remove('visible');
                updateUI();
            }, 1500);
        }

        // Damage
        function takeDamage(amount) {
            health -= amount;
            playSound('damage');

            if (health <= 0) {
                health = 0;
                endGame();
            }

            updateUI();
        }

        function showDamage() {
            const overlay = document.getElementById('damageOverlay');
            overlay.style.opacity = '1';
            setTimeout(() => overlay.style.opacity = '0', 200);
        }

        // UI Updates
        function updateUI() {
            document.getElementById('health-bar').style.width = `${(health / maxHealth) * 100}%`;
            document.getElementById('health-text').textContent = `${Math.ceil(health)} / ${maxHealth}`;
            document.getElementById('ammo-display').textContent = `${ammo} / ${totalAmmo}`;
            document.getElementById('score').textContent = score;
            document.getElementById('kills').textContent = `${kills} KILLS`;
            document.getElementById('wave-number').textContent = `WAVE ${wave}`;
            document.getElementById('enemies-remaining').textContent = `Enemies: ${enemiesRemaining}`;
        }

        function showKillMessage(customText = 'Enemy eliminated +100') {
            const feed = document.getElementById('killFeed');
            const msg = document.createElement('div');
            msg.className = 'kill-message';
            msg.textContent = customText;
            msg.style.color = customText.includes('BOSS') ? '#e74c3c' : '#fff';
            msg.style.fontSize = customText.includes('BOSS') ? '18px' : '14px';
            feed.appendChild(msg);

            setTimeout(() => {
                msg.style.opacity = '0';
                setTimeout(() => msg.remove(), 500);
            }, 2000);
        }

        // Controls
        function setupControls() {
            // Pointer lock
            canvas.addEventListener('click', () => {
                if (gameStarted && !gameOver) {
                    canvas.requestPointerLock();
                    shoot();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                if (!document.pointerLockElement && gameStarted && !gameOver) {
                    // Paused
                }
            });

            document.addEventListener('mousemove', (event) => {
                if (!gameStarted || gameOver) return;
                if (document.pointerLockElement !== canvas) return;

                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                euler.setFromQuaternion(camera.quaternion);
                euler.y -= movementX * 0.002;
                euler.x -= movementY * 0.002;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                camera.quaternion.setFromEuler(euler);
            });

            document.addEventListener('keydown', (event) => {
                if (!gameStarted || gameOver) return;

                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': moveState.forward = true; break;
                    case 'KeyS': case 'ArrowDown': moveState.backward = true; break;
                    case 'KeyA': case 'ArrowLeft': moveState.left = true; break;
                    case 'KeyD': case 'ArrowRight': moveState.right = true; break;
                    case 'Space':
                        if (player.onGround) {
                            player.velocity.y = player.jumpForce;
                            player.onGround = false;
                        }
                        break;
                    case 'KeyR': reload(); break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': case 'ArrowUp': moveState.forward = false; break;
                    case 'KeyS': case 'ArrowDown': moveState.backward = false; break;
                    case 'KeyA': case 'ArrowLeft': moveState.left = false; break;
                    case 'KeyD': case 'ArrowRight': moveState.right = false; break;
                }
            });
        }

        // Physics
        function checkCollision(newPos) {
            const playerRadius = 0.5;
            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - playerRadius, 0, newPos.z - playerRadius),
                new THREE.Vector3(newPos.x + playerRadius, 4, newPos.z + playerRadius)
            );

            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) {
                    return true;
                }
            }

            return false;
        }

        // Game Loop
        const clock = new THREE.Clock();

        function update() {
            if (!gameStarted || gameOver) return;

            const delta = Math.min(clock.getDelta(), 0.1);
            const time = performance.now() / 1000;

            // Player movement
            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            if (moveState.forward) direction.add(forward);
            if (moveState.backward) direction.sub(forward);
            if (moveState.left) direction.sub(right);
            if (moveState.right) direction.add(right);
            direction.normalize();

            // Apply velocity
            player.velocity.x = direction.x * player.speed;
            player.velocity.z = direction.z * player.speed;

            // Gravity
            player.velocity.y -= 30 * delta;

            // Calculate new position
            const newPos = player.position.clone();
            newPos.x += player.velocity.x * delta;
            newPos.y += player.velocity.y * delta;
            newPos.z += player.velocity.z * delta;

            // Collision detection
            if (!checkCollision(new THREE.Vector3(newPos.x, player.position.y, player.position.z))) {
                player.position.x = newPos.x;
            }
            if (!checkCollision(new THREE.Vector3(player.position.x, player.position.y, newPos.z))) {
                player.position.z = newPos.z;
            }

            // Ground collision
            if (newPos.y <= 2) {
                newPos.y = 2;
                player.velocity.y = 0;
                player.onGround = true;
            }

            player.position.copy(newPos);

            // Update camera
            camera.position.copy(player.position);
            camera.position.y = 2;

            // Update enemies
            enemies.forEach(enemy => enemy.update(delta, player.position));

            // Update pickups
            updatePickups(time);

            // Check wave complete
            if (enemiesRemaining <= 0) {
                checkWaveComplete();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        // Game State Management
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            initAudio();
            createArena();
            setupLighting();
            setupControls();

            gameStarted = true;
            gameOver = false;
            score = 0;
            kills = 0;
            wave = 1;
            health = maxHealth;
            ammo = maxAmmo;
            totalAmmo = 90;

            startWave();
            updateUI();
            canvas.requestPointerLock();
        }

        function endGame() {
            gameOver = true;
            document.exitPointerLock();

            document.getElementById('gameOverScreen').style.display = 'flex';
            document.getElementById('gameOverScreen').querySelector('#final-score').textContent = `Final Score: ${score}`;
            document.getElementById('hud').style.display = 'none';
        }

        function restartGame() {
            // Clear enemies
            enemies.forEach(e => {
                if (e.alive) scene.remove(e.mesh);
            });
            enemies.length = 0;

            // Clear pickups
            pickups.forEach(p => scene.remove(p.mesh));
            pickups.length = 0;

            // Reset player
            player.position.set(0, 2, 0);
            player.velocity.set(0, 0, 0);

            // Hide game over screen
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            // Reset game state
            gameOver = false;
            score = 0;
            kills = 0;
            wave = 1;
            health = maxHealth;
            ammo = maxAmmo;
            totalAmmo = 90;

            startWave();
            updateUI();
            canvas.requestPointerLock();
        }

        // Event Listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', restartGame);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>
