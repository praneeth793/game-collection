<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Arena - 3D Survival</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* HUD Layer */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.9);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #crosshair::before {
            width: 2px;
            height: 24px;
            left: 11px;
            top: 0;
        }

        #crosshair::after {
            width: 24px;
            height: 2px;
            top: 11px;
            left: 0;
        }

        /* Health Bar */
        #healthContainer {
            position: fixed;
            top: 25px;
            left: 25px;
            width: 220px;
            height: 28px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffff;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        #healthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ffcc);
            transition: width 0.3s ease, background 0.3s ease;
        }

        #healthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }

        /* Stats Panel */
        #statsPanel {
            position: fixed;
            top: 25px;
            right: 25px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stat-box {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid;
            border-radius: 6px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
        }

        .stat-box.score {
            border-color: #ff00ff;
            color: #ff00ff;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .stat-box.wave {
            border-color: #ffaa00;
            color: #ffaa00;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
        }

        .stat-box.enemies {
            border-color: #ff4444;
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #startScreen h1 {
            font-size: 64px;
            color: #00ffff;
            margin-bottom: 10px;
            text-shadow: 
                0 0 20px rgba(0, 255, 255, 0.8),
                0 0 40px rgba(0, 255, 255, 0.5),
                0 0 60px rgba(0, 255, 255, 0.3);
            animation: neonPulse 2s ease-in-out infinite;
        }

        @keyframes neonPulse {
            0%, 100% { 
                text-shadow: 
                    0 0 20px rgba(0, 255, 255, 0.8),
                    0 0 40px rgba(0, 255, 255, 0.5),
                    0 0 60px rgba(0, 255, 255, 0.3);
                transform: scale(1);
            }
            50% { 
                text-shadow: 
                    0 0 30px rgba(0, 255, 255, 1),
                    0 0 60px rgba(0, 255, 255, 0.7),
                    0 0 90px rgba(0, 255, 255, 0.5);
                transform: scale(1.02);
            }
        }

        #startScreen .subtitle {
            color: #888;
            font-size: 18px;
            margin-bottom: 40px;
            letter-spacing: 3px;
        }

        #startScreen .controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 25px 40px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
        }

        #startScreen .controls h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 16px;
            letter-spacing: 2px;
        }

        #startScreen .controls p {
            color: #aaa;
            font-size: 15px;
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #startScreen .controls kbd {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 4px;
            padding: 4px 10px;
            color: #00ffff;
            font-family: monospace;
        }

        #startButton {
            padding: 18px 60px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #00ffff, #00cccc);
            border: none;
            border-radius: 30px;
            color: #0a0a0f;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 2px;
        }

        #startButton:hover {
            transform: scale(1.08);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
        }

        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #gameOverScreen h1 {
            font-size: 72px;
            color: #ff4444;
            margin-bottom: 30px;
            text-shadow: 0 0 30px rgba(255, 68, 68, 0.8);
            animation: glitch 0.5s ease-in-out infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }

        #finalStats {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 40px;
        }

        #finalStats .stat {
            color: #fff;
            font-size: 24px;
            text-align: center;
        }

        #finalStats .stat span {
            color: #00ffff;
            font-weight: bold;
        }

        #restartButton {
            padding: 18px 60px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            border: none;
            border-radius: 30px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #restartButton:hover {
            transform: scale(1.08);
            box-shadow: 0 0 40px rgba(255, 68, 68, 0.6);
        }

        /* Wave Announcement */
        #waveAnnounce {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ffaa00;
            text-shadow: 0 0 30px rgba(255, 170, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            z-index: 150;
            transition: opacity 0.3s ease;
        }

        #waveAnnounce.show {
            opacity: 1;
        }

        /* Damage Flash */
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.4) 0%, transparent 70%);
            pointer-events: none;
            opacity: 0;
            z-index: 140;
        }

        /* Kill Feed */
        #killFeed {
            position: fixed;
            top: 100px;
            right: 25px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 90;
        }

        .kill-msg {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 4px;
            color: #ff4444;
            font-size: 13px;
            animation: slideIn 0.3s ease, fadeOut 0.5s ease 2s forwards;
        }

        @keyframes slideIn {
            from { transform: translateX(50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        /* Instructions */
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 13px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div id="healthContainer">
            <div id="healthBar"></div>
            <span id="healthText">100 HP</span>
        </div>
        
        <div id="statsPanel">
            <div class="stat-box score">ðŸ’Ž Score: <span id="score">0</span></div>
            <div class="stat-box wave">ðŸŒŠ Wave: <span id="wave">1</span></div>
            <div class="stat-box enemies">ðŸ‘¾ <span id="enemiesLeft">0</span> remaining</div>
        </div>
        
        <div id="crosshair"></div>
        
        <div id="killFeed"></div>
    </div>

    <!-- Damage Flash -->
    <div id="damageFlash"></div>

    <!-- Wave Announcement -->
    <div id="waveAnnounce">Wave 1</div>

    <!-- Start Screen -->
    <div id="startScreen">
        <h1>NEON ARENA</h1>
        <p class="subtitle">SURVIVE THE MACHINE HORDE</p>
        
        <div class="controls">
            <h3>CONTROLS</h3>
            <p><kbd>W A S D</kbd> Move</p>
            <p><kbd>SPACE</kbd> Jump</p>
            <p><kbd>SHIFT</kbd> Sprint</p>
            <p><kbd>MOUSE</kbd> Look Around</p>
            <p><kbd>CLICK</kbd> Lock Pointer</p>
            <p style="margin-top: 15px; color: #00ff88;">ðŸ’Ž Collect orbs for points</p>
            <p style="color: #ff4444;">ðŸ‘¾ Destroy enemy robots</p>
        </div>
        
        <button id="startButton">ENTER ARENA</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1>SYSTEM FAILED</h1>
        <div id="finalStats">
            <div class="stat">Final Score: <span id="finalScore">0</span></div>
            <div class="stat">Wave Reached: <span id="finalWave">1</span></div>
            <div class="stat">Enemies Destroyed: <span id="finalKills">0</span></div>
        </div>
        <button id="restartButton">REBOOT SYSTEM</button>
    </div>

    <!-- Instructions -->
    <div id="instructions">Press ESC to show cursor</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        /**
         * NEON ARENA - 3D Survival Game
         * 
         * A fast-paced arena shooter where you:
         * - Survive waves of enemy robots
         * - Collect glowing energy orbs
         * - Progress through increasingly difficult waves
         * 
         * Features:
         * - First-person combat with smooth controls
         * - Enemy AI with patrol and chase behaviors
         * - Wave-based progression system
         * - Score tracking and kill feed
         * - Neon-styled low-poly visuals
         * - Procedural audio using Web Audio API
         */

        // ==========================================
        // AUDIO SYSTEM
        // ==========================================
        class AudioSystem {
            constructor() {
                this.ctx = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.log('Audio not supported');
                }
            }

            playTone(freq, duration, type = 'sine', vol = 0.2) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playCollect() {
                this.playTone(880, 0.08, 'sine', 0.2);
                setTimeout(() => this.playTone(1320, 0.12, 'sine', 0.15), 60);
            }

            playJump() {
                this.playTone(200, 0.1, 'triangle', 0.15);
            }

            playShoot() {
                this.playTone(150, 0.05, 'sawtooth', 0.15);
                this.playTone(100, 0.08, 'square', 0.1);
            }

            playHit() {
                this.playTone(80, 0.15, 'sawtooth', 0.25);
                setTimeout(() => this.playTone(60, 0.2, 'sawtooth', 0.2), 50);
            }

            playEnemyDie() {
                const notes = [400, 300, 200];
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.15, 'square', 0.2), i * 50);
                });
            }

            playWaveStart() {
                const chord = [220, 330, 440];
                chord.forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.4, 'sine', 0.15), i * 80);
                });
            }

            playGameOver() {
                const notes = [400, 350, 300, 250, 200];
                notes.forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.3, 'sawtooth', 0.2), i * 150);
                });
            }
        }

        // ==========================================
        // GAME CLASS
        // ==========================================
        class NeonArena {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.audio = new AudioSystem();

                // Game state
                this.isPlaying = false;
                this.score = 0;
                this.wave = 1;
                this.kills = 0;
                this.enemiesRemaining = 0;

                // Player
                this.player = {
                    position: new THREE.Vector3(0, 2, 0),
                    velocity: new THREE.Vector3(),
                    onGround: false,
                    speed: 18,
                    sprintMultiplier: 1.5,
                    jumpForce: 22,
                    gravity: -60,
                    height: 1.8,
                    health: 100,
                    maxHealth: 100
                };

                // Input
                this.keys = {};

                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.rotation.order = 'YXZ';

                // Three.js
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0f);
                this.scene.fog = new THREE.FogExp2(0x0a0a0f, 0.015);

                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Entities
                this.orbs = [];
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];

                // Clock
                this.clock = new THREE.Clock();

                this.init();
            }

            init() {
                this.setupLights();
                this.createArena();
                this.setupEventListeners();
                this.animate();
            }

            setupLights() {
                // Ambient
                const ambient = new THREE.AmbientLight(0x222233, 0.4);
                this.scene.add(ambient);

                // Main directional light
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
                dirLight.position.set(30, 50, 30);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5;
                dirLight.shadow.camera.far = 200;
                dirLight.shadow.camera.left = -60;
                dirLight.shadow.camera.right = 60;
                dirLight.shadow.camera.top = 60;
                dirLight.shadow.camera.bottom = -60;
                this.scene.add(dirLight);

                // Neon accent lights
                const colors = [0x00ffff, 0xff00ff, 0x00ff88];
                colors.forEach((color, i) => {
                    const light = new THREE.PointLight(color, 1, 40);
                    const angle = (i / 3) * Math.PI * 2;
                    light.position.set(Math.cos(angle) * 25, 10, Math.sin(angle) * 25);
                    this.scene.add(light);
                });

                // Player glow
                this.playerLight = new THREE.PointLight(0x00ffff, 1, 20);
                this.camera.add(this.playerLight);
                this.scene.add(this.camera);
            }

            createArena() {
                // Floor
                const floorGeom = new THREE.PlaneGeometry(120, 120, 20, 20);
                const floorMat = new THREE.MeshStandardMaterial({
                    color: 0x1a1a2e,
                    roughness: 0.8,
                    metalness: 0.3
                });
                const floor = new THREE.Mesh(floorGeom, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);

                // Grid pattern on floor
                const gridHelper = new THREE.GridHelper(120, 60, 0x00ffff, 0x111133);
                gridHelper.position.y = 0.01;
                this.scene.add(gridHelper);

                // Walls
                const wallGeom = new THREE.BoxGeometry(120, 15, 2);
                const wallMat = new THREE.MeshStandardMaterial({
                    color: 0x2a2a4e,
                    roughness: 0.6,
                    metalness: 0.4,
                    transparent: true,
                    opacity: 0.8
                });

                const walls = [
                    { x: 0, z: -60, rot: 0 },
                    { x: 0, z: 60, rot: 0 },
                    { x: -60, z: 0, rot: Math.PI / 2 },
                    { x: 60, z: 0, rot: Math.PI / 2 }
                ];

                walls.forEach(w => {
                    const wall = new THREE.Mesh(wallGeom, wallMat);
                    wall.position.set(w.x, 7.5, w.z);
                    wall.rotation.y = w.rot;
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    this.scene.add(wall);
                });

                // Arena center marker
                const centerGeom = new THREE.RingGeometry(3, 4, 32);
                const centerMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                const center = new THREE.Mesh(centerGeom, centerMat);
                center.rotation.x = -Math.PI / 2;
                center.position.y = 0.02;
                this.scene.add(center);

                // Pillars
                this.createPillars();
            }

            createPillars() {
                const pillarGeom = new THREE.CylinderGeometry(1.5, 1.5, 12, 8);
                const pillarMat = new THREE.MeshStandardMaterial({
                    color: 0x2a2a4e,
                    roughness: 0.5,
                    metalness: 0.5
                });

                const positions = [
                    [-20, -20], [-20, 20], [20, -20], [20, 20],
                    [-35, 0], [35, 0], [0, -35], [0, 35]
                ];

                positions.forEach(pos => {
                    const pillar = new THREE.Mesh(pillarGeom, pillarMat);
                    pillar.position.set(pos[0], 6, pos[1]);
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    this.scene.add(pillar);

                    // Neon strip on pillar
                    const stripGeom = new THREE.BoxGeometry(0.3, 10, 0.3);
                    const stripMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                    const strip = new THREE.Mesh(stripGeom, stripMat);
                    strip.position.set(pos[0], 5, pos[1]);
                    this.scene.add(strip);
                });
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space' && this.player.onGround && this.isPlaying) {
                        this.player.velocity.y = this.player.jumpForce;
                        this.player.onGround = false;
                        this.audio.playJump();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === this.canvas && this.isPlaying) {
                        const sens = 0.002;
                        this.camera.rotation.y -= e.movementX * sens;
                        this.camera.rotation.x -= e.movementY * sens;
                        this.camera.rotation.x = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, this.camera.rotation.x));
                    }
                });

                document.addEventListener('click', () => {
                    if (this.isPlaying && document.pointerLockElement !== this.canvas) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.getElementById('startButton').addEventListener('click', () => {
                    this.audio.init();
                    this.startGame();
                });

                document.getElementById('restartButton').addEventListener('click', () => {
                    this.restartGame();
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            startGame() {
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('gameOverScreen').style.display = 'none';
                this.isPlaying = true;
                this.canvas.requestPointerLock();
                this.startWave();
            }

            restartGame() {
                // Reset stats
                this.score = 0;
                this.wave = 1;
                this.kills = 0;
                this.player.health = 100;
                this.player.position.set(0, 2, 0);
                this.player.velocity.set(0, 0, 0);
                this.camera.rotation.set(0, 0, 0);

                // Clear entities
                this.orbs.forEach(o => this.scene.remove(o.mesh));
                this.enemies.forEach(e => this.scene.remove(e.mesh));
                this.particles.forEach(p => this.scene.remove(p.mesh));
                this.orbs = [];
                this.enemies = [];
                this.particles = [];

                // Update HUD
                this.updateHUD();

                // Start game
                this.startGame();
            }

            startWave() {
                const enemyCount = 3 + this.wave * 2;
                this.enemiesRemaining = enemyCount;
                this.updateHUD();

                // Announce wave
                const announce = document.getElementById('waveAnnounce');
                announce.textContent = `Wave ${this.wave}`;
                announce.classList.add('show');
                this.audio.playWaveStart();
                setTimeout(() => announce.classList.remove('show'), 2000);

                // Spawn enemies
                for (let i = 0; i < enemyCount; i++) {
                    this.spawnEnemy();
                }

                // Spawn orbs
                this.spawnOrbs(5 + this.wave);
            }

            spawnEnemy() {
                // Robot enemy
                const bodyGeom = new THREE.BoxGeometry(1.5, 2, 1);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xff4444,
                    roughness: 0.4,
                    metalness: 0.6,
                    emissive: 0x330000,
                    emissiveIntensity: 0.3
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);

                // Head
                const headGeom = new THREE.BoxGeometry(1, 0.8, 0.8);
                const head = new THREE.Mesh(headGeom, bodyMat);
                head.position.y = 1.4;
                body.add(head);

                // Eyes
                const eyeGeom = new THREE.BoxGeometry(0.25, 0.15, 0.1);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                leftEye.position.set(-0.25, 1.5, 0.4);
                body.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                rightEye.position.set(0.25, 1.5, 0.4);
                body.add(rightEye);

                // Random spawn position
                const angle = Math.random() * Math.PI * 2;
                const dist = 20 + Math.random() * 25;
                body.position.set(
                    Math.cos(angle) * dist,
                    1,
                    Math.sin(angle) * dist
                );
                body.castShadow = true;

                this.scene.add(body);

                this.enemies.push({
                    mesh: body,
                    health: 2 + Math.floor(this.wave / 3),
                    speed: 8 + this.wave * 0.5,
                    state: 'patrol',
                    patrolTimer: 0,
                    patrolDir: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize()
                });
            }

            spawnOrbs(count) {
                const orbGeom = new THREE.OctahedronGeometry(0.5, 0);
                const orbMat = new THREE.MeshStandardMaterial({
                    color: 0xff00ff,
                    emissive: 0xff00ff,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.9
                });

                for (let i = 0; i < count; i++) {
                    const orb = new THREE.Mesh(orbGeom, orbMat.clone());
                    orb.position.set(
                        (Math.random() - 0.5) * 80,
                        1.5,
                        (Math.random() - 0.5) * 80
                    );
                    
                    // Glow light
                    const light = new THREE.PointLight(0xff00ff, 0.5, 8);
                    orb.add(light);

                    this.scene.add(orb);
                    this.orbs.push({
                        mesh: orb,
                        collected: false
                    });
                }
            }

            updatePlayer(delta) {
                if (!this.isPlaying) return;

                const p = this.player;
                const speed = p.speed * (this.keys['ShiftLeft'] || this.keys['ShiftRight'] ? p.sprintMultiplier : 1);

                // Movement
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(this.camera.quaternion);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(this.camera.quaternion);
                right.y = 0;
                right.normalize();

                p.velocity.x = 0;
                p.velocity.z = 0;

                if (this.keys['KeyW'] || this.keys['ArrowUp']) p.velocity.add(forward.multiplyScalar(speed));
                if (this.keys['KeyS'] || this.keys['ArrowDown']) p.velocity.sub(forward.multiplyScalar(speed));
                if (this.keys['KeyD'] || this.keys['ArrowRight']) p.velocity.add(right.multiplyScalar(speed));
                if (this.keys['KeyA'] || this.keys['ArrowLeft']) p.velocity.sub(right.multiplyScalar(speed));

                // Apply velocity
                p.position.x += p.velocity.x * delta;
                p.position.z += p.velocity.z * delta;

                // Gravity
                p.velocity.y += p.gravity * delta;
                p.position.y += p.velocity.y * delta;

                // Ground collision
                if (p.position.y <= p.height) {
                    p.position.y = p.height;
                    p.velocity.y = 0;
                    p.onGround = true;
                }

                // Wall boundaries
                p.position.x = Math.max(-57, Math.min(57, p.position.x));
                p.position.z = Math.max(-57, Math.min(57, p.position.z));

                // Update camera
                this.camera.position.copy(p.position);
                this.camera.position.y = p.position.y - 0.5;
            }

            updateEnemies(delta) {
                this.enemies.forEach((enemy, index) => {
                    const mesh = enemy.mesh;
                    const toPlayer = this.player.position.clone().sub(mesh.position);
                    const distToPlayer = toPlayer.length();

                    // AI State machine
                    if (distToPlayer < 25) {
                        enemy.state = 'chase';
                    } else if (distToPlayer > 35) {
                        enemy.state = 'patrol';
                    }

                    // Movement
                    if (enemy.state === 'chase') {
                        toPlayer.normalize();
                        mesh.position.x += toPlayer.x * enemy.speed * delta;
                        mesh.position.z += toPlayer.z * enemy.speed * delta;
                        mesh.lookAt(this.player.position.x, mesh.position.y, this.player.position.z);
                    } else {
                        enemy.patrolTimer += delta;
                        if (enemy.patrolTimer > 3) {
                            enemy.patrolDir = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                            enemy.patrolTimer = 0;
                        }
                        mesh.position.x += enemy.patrolDir.x * enemy.speed * 0.5 * delta;
                        mesh.position.z += enemy.patrolDir.z * enemy.speed * 0.5 * delta;
                        
                        // Keep in bounds
                        mesh.position.x = Math.max(-55, Math.min(55, mesh.position.x));
                        mesh.position.z = Math.max(-55, Math.min(55, mesh.position.z));
                    }

                    // Bobbing animation
                    mesh.position.y = 1 + Math.sin(Date.now() * 0.005 + index) * 0.2;

                    // Collision with player
                    if (distToPlayer < 2.5) {
                        this.damagePlayer(15);
                        // Knockback
                        const knockback = toPlayer.normalize().multiplyScalar(10);
                        this.player.velocity.add(knockback);
                    }
                });
            }

            updateOrbs(delta, time) {
                this.orbs.forEach((orb, index) => {
                    if (orb.collected) return;

                    // Rotate and float
                    orb.mesh.rotation.y += delta * 2;
                    orb.mesh.position.y = 1.5 + Math.sin(time * 2 + index) * 0.3;

                    // Check collection
                    if (this.player.position.distanceTo(orb.mesh.position) < 2) {
                        this.collectOrb(index);
                    }
                });
            }

            updateParticles(delta) {
                this.particles.forEach((p, index) => {
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(delta));
                    p.life -= delta;
                    p.mesh.material.opacity = p.life * 0.5;
                    p.mesh.scale.multiplyScalar(0.98);

                    if (p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(index, 1);
                    }
                });
            }

            collectOrb(index) {
                const orb = this.orbs[index];
                if (orb.collected) return;
                orb.collected = true;
                this.scene.remove(orb.mesh);
                this.score += 100;
                this.audio.playCollect();
                this.createCollectEffect(orb.mesh.position);
                this.updateHUD();
            }

            damageEnemy(enemyIndex) {
                const enemy = this.enemies[enemyIndex];
                enemy.health--;
                enemy.mesh.material.emissive.setHex(0xffffff);
                setTimeout(() => {
                    if (enemy.mesh) {
                        enemy.mesh.material.emissive.setHex(0x330000);
                    }
                }, 100);

                if (enemy.health <= 0) {
                    this.destroyEnemy(enemyIndex);
                }
            }

            destroyEnemy(index) {
                const enemy = this.enemies[index];
                this.createCollectEffect(enemy.mesh.position);
                this.scene.remove(enemy.mesh);
                this.enemies.splice(index, 1);
                this.kills++;
                this.enemiesRemaining--;
                this.score += 50 * this.wave;
                this.audio.playEnemyDie();
                this.addKillMessage(`Enemy destroyed! +${50 * this.wave}`);
                this.updateHUD();

                // Check wave completion
                if (this.enemies.length === 0) {
                    this.wave++;
                    setTimeout(() => this.startWave(), 2000);
                }
            }

            createCollectEffect(position) {
                const count = 10;
                const geom = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.5 
                });

                for (let i = 0; i < count; i++) {
                    const mesh = new THREE.Mesh(geom, mat);
                    mesh.position.copy(position);
                    this.scene.add(mesh);

                    this.particles.push({
                        mesh,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 10,
                            Math.random() * 8,
                            (Math.random() - 0.5) * 10
                        ),
                        life: 1
                    });
                }
            }

            damagePlayer(amount) {
                this.player.health -= amount;
                this.audio.playHit();

                // Flash effect
                const flash = document.getElementById('damageFlash');
                flash.style.opacity = '1';
                setTimeout(() => flash.style.opacity = '0', 150);

                this.updateHUD();

                if (this.player.health <= 0) {
                    this.gameOver();
                }
            }

            gameOver() {
                this.isPlaying = false;
                document.exitPointerLock();
                this.audio.playGameOver();

                document.getElementById('gameOverScreen').style.display = 'flex';
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalWave').textContent = this.wave;
                document.getElementById('finalKills').textContent = this.kills;
            }

            addKillMessage(msg) {
                const feed = document.getElementById('killFeed');
                const el = document.createElement('div');
                el.className = 'kill-msg';
                el.textContent = msg;
                feed.appendChild(el);
                setTimeout(() => el.remove(), 2500);
            }

            updateHUD() {
                document.getElementById('healthBar').style.width = `${this.player.health}%`;
                document.getElementById('healthText').textContent = `${Math.max(0, this.player.health)} HP`;
                document.getElementById('score').textContent = this.score;
                document.getElementById('wave').textContent = this.wave;
                document.getElementById('enemiesLeft').textContent = this.enemies.length;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const delta = Math.min(this.clock.getDelta(), 0.1);
                const time = this.clock.getElapsedTime();

                this.updatePlayer(delta);
                this.updateEnemies(delta);
                this.updateOrbs(delta, time);
                this.updateParticles(delta);

                // Update enemies remaining display
                document.getElementById('enemiesLeft').textContent = this.enemies.length;

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start the game
        new NeonArena();
    </script>
</body>
</html>
